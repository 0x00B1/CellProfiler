""" cpmorphology.py - morphological operations not in scipy

"""
__version__="$Revision: 1 "

import numpy
import scipy.ndimage
import scipy.sparse
import _cpmorphology
from outline import outline 

def fill_labeled_holes(image):
    """Fill holes in objects in a labeled image
    
    image - a label matrix, for instance as generated by scipy.ndimage.label
    This algorithm takes a labeled image and fills any hole (unlabeled 
    pixels surrounded solely by one label). The key insight is that if
    you generate a binary image composed of the unlabeled points and
    you label it, each hole gets a unique label. After that, you can get
    rid of any labeled "hole" that's touching the border and any labeled
    "hole" that's touching more than one labeled object (space between two
    touching objects). A further trick is to figure out whether a hole
    touches more than one object or the edge. To get the min and the max,
    ignoring the holes, we label the holes as zero in the labeled image
    for the max (already done) and label them with infinity (more or less)
    when doing the min. Finally, we can get rid of the "holes" touching
    the border by labeling the border with zero (by choosing a mode of
    "constant" and a cval of zero) so that their min will differ from
    the maximum object they touch.
    
    If you 8-connect objects, then you must 4-connect the holes to
    keep holes like the following from connecting with the outside world:
    * 1 *
    1 @ 1
    * 1 *
    where * is outside background, @ is inside background and 1 is foreground.
    """
    four_connect = scipy.ndimage.generate_binary_structure(2, 1)
    negative_mask = (image == 0)
    labeled_holes, nholes = scipy.ndimage.label(negative_mask,four_connect)
    high = image.max()+1
    image_with_high_holes = image.copy()
    image_with_high_holes[labeled_holes > 0] = high
    min_label = scipy.ndimage.minimum_filter(image_with_high_holes,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    max_label = scipy.ndimage.maximum_filter(image,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    min_label_per_hole = scipy.ndimage.minimum(min_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = scipy.ndimage.maximum(max_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = numpy.array(max_label_per_hole)
    hole_label = numpy.array(min_label_per_hole)
    hole_label[hole_label != max_label_per_hole] = 0
    hole_mask = hole_label[labeled_holes] > 0
    output_image = image.copy()
    output_image[hole_mask] = hole_label[labeled_holes[hole_mask]]
    return output_image

def binary_thin(image, strel1, strel2):
    """Morphologically thin an image
    strel1 - the required values of the pixels in order to survive
    strel2 - at each pixel, the complement of strel1 if we care about the value
    """
    hit_or_miss = scipy.ndimage.binary_hit_or_miss(image, strel1, strel2)
    return numpy.logical_and(image,numpy.logical_not(hit_or_miss))

def binary_shrink(image, iterations=-1):
    """Shrink an image by repeatedly removing pixels which have partners
       above, to the left, to the right and below until the image doesn't change
       
       image - binary image to be manipulated
       iterations - # of times to shrink, -1 to shrink until idempotent
       
       There are horizontal/vertical thinners which detect a pixel on
       an edge with an interior pixel either horizontally or vertically
       attached like this:
       0  0  0
       X  1  X
       X  1  X
       and there are much more specific diagonal thinners which detect
       a pixel on the edge of a diagonal, like this:
       0  0  0
       0  1  0
       0  0  1
       Rotate each of these 4x to get the four directions for each
    """
    hv_thinner = numpy.array([[False,False,False],[False,True,False],[False,True,False]])
    hv_anti_thinner = numpy.array([[True,True,True],[False,False,False],[False,False,False]])
    d_thinner = numpy.array([[False,False,False],[False,True,False],[False,False,True]])
    d_anti_thinner = numpy.array([[True,True,True],[True,False,True],[True,True,False]])
    thinners = []
    anti_thinners = []
    for thinner,anti_thinner in ((hv_thinner, hv_anti_thinner),(d_thinner,d_anti_thinner)):
        for n in range(4):
            thinners.append(numpy.lib.rot90(thinner,n))
            anti_thinners.append(numpy.lib.rot90(anti_thinner,n))
    if iterations == -1:
        iterations = 10000
    result = image
    for n in range(iterations):
        temp = result.copy()
        for thinner,anti_thinner in zip(thinners,anti_thinners):
            temp = binary_thin(temp,thinner,anti_thinner)
        if numpy.all(temp==result):
            return result
        result=temp

def strel_disk(radius):
    """Create a disk structuring element for morphological operations
    
    radius - radius of the disk
    """
    iradius = int(radius)
    x,y     = numpy.mgrid[-iradius:iradius+1,-iradius:iradius+1]
    radius2 = radius * radius
    strel   = numpy.zeros(x.shape)
    strel[x*x+y*y <= radius2] = 1
    return strel

def cpmaximum(image, structure=numpy.ones((3,3),dtype=bool),offset=None):
    """Find the local maximum at each point in the image, using the given structuring element
    
    image - a 2-d array of doubles
    structure - a boolean structuring element indicating which
                local elements should be sampled
    offset - the offset to the center of the structuring element
    """
    if not offset:
        offset = (structure.shape[0]/2,structure.shape[1]/2)
    offset = tuple(offset)
    return _cpmorphology.cpmaximum(image,structure,offset)

def relabel(image):
    """Given a labeled image, relabel each of the objects consecutively
    
    image - a labeled 2-d integer array
    returns - (labeled image, object count) 
    """
    #
    # Build a label table that converts an old label # into
    # labels using the new numbering scheme
    #
    unique_labels = numpy.unique(image)
    consecutive_labels = numpy.array(range(len(unique_labels)+1))
    label_table = numpy.ndarray(((unique_labels[-1]+1),),int)
    for old,new in zip(unique_labels,consecutive_labels):
        label_table[old]=new
    #
    # Use the label table to remap all of the labels
    #
    new_image = label_table[image]
    return (new_image,len(unique_labels)-1)

def convex_hull(labels, indexes=None):
    """Given a labeled image, return a list of points per object ordered by
    angle from an interior point, representing the convex hull.
    
    labels - the label matrix
    indexes - an array of label #s to be processed, defaults to all non-zero
              labels
    
    Returns a matrix and a vector. The matrix consists of one row per
    point in the convex hull. Each row has three columns, the label #,
    the i coordinate of the point and the j coordinate of the point. The
    result is organized first by label, then the points are arranged
    counter-clockwise around the perimeter.
    The vector is a vector of #s of points in the convex hull per label
    """
    if indexes == None:
        indexes = numpy.unique(labels)
        indexes.sort()
        indexes=indexes[indexes!=0]
    else:
        indexes=numpy.array(indexes)
    if len(indexes) == 0:
        return numpy.zeros((0,2),int),numpy.zeros((0,),int)
    #
    # An array that converts from label # to index in "indexes"
    anti_indexes = numpy.zeros((numpy.max(indexes)+1,),int)
    anti_indexes[indexes] = range(len(indexes))
    #
    # Reduce the # of points to consider
    #
    outlines = outline(labels)
    centers  = scipy.ndimage.center_of_mass(outlines,outlines, indexes)
    centers = numpy.array([centers])
    centers.shape=(indexes.shape[0],2) # if max_label = 1, you get 1d array
    #
    # Now make an array with one outline point per row and the following
    # columns:
    #
    # index of label # in indexes array
    # angle of the point relative to the center
    # i coordinate of the point
    # j coordinate of the point
    #
    coords = numpy.argwhere(outlines > 0)
    if len(coords)==0:
        # Every outline of every image is blank
        return (numpy.zeros((0,3),int),
                numpy.zeros((len(indexes),),int))
    
    i = coords[:,0]
    j = coords[:,1]
    labels_per_point = labels[i,j]
    anti_indexes_per_point = anti_indexes[labels_per_point]
    centers_per_point = centers[anti_indexes_per_point]
    angle = numpy.arctan2(i-centers_per_point[:,0],j-centers_per_point[:,1])
    a = numpy.zeros((len(i),3),int)
    a[:,0] = anti_indexes_per_point
    a[:,1:] = coords
    #
    # Sort the array first by label # (sort of), then by angle
    #
    order = numpy.lexsort((angle,anti_indexes_per_point))
    a=a[order]
    anti_indexes_per_point = anti_indexes_per_point[order]
    angle = angle[order]
    centers_per_point = centers_per_point[order]
    #
    # Make the result matrix, leaving enough space so that all points might
    # be on the convex hull.
    #
    result = numpy.zeros((len(i),3),int)
    result[:,0] = labels_per_point[order]
    #
    # Create an initial count vector
    #
    v = numpy.ones((a.shape[0],),dtype=int)
    result_counts = scipy.sparse.coo_matrix((v,(a[:,0],v*0)),
                                            shape=(len(indexes),1))
    result_counts = result_counts.toarray().flatten()
    r_anti_indexes_per_point = anti_indexes_per_point # save this
    #
    # Create a vector that indexes into the results for each label
    #
    result_index = numpy.zeros(result_counts.shape,int)
    result_index[1:]=numpy.cumsum(result_counts[:-1])
    #
    # Initialize the counts of convex hull points to a ridiculous number
    #
    counts = numpy.ones((len(indexes),),int) * (numpy.product(labels.shape)+1)
    while True:
        #
        # Figure out how many putative convex hull points there are for
        # each label.
        #
        # If the count for a label is 3 or less, it's a convex hull or
        # degenerate case.
        #
        # If the count hasn't changed in an iteration, then we've done
        # as well as we can hope to do.
        #
        v = numpy.ones((a.shape[0],),dtype=int)
        new_counts = scipy.sparse.coo_matrix((v,(a[:,0],v*0)),
                                             shape=(len(indexes),1))
        new_counts = new_counts.toarray().flatten()
        finish_me = numpy.logical_and(new_counts > 0,
                                      numpy.logical_or(new_counts <= 3,
                                                       new_counts == counts))
        indexes_to_finish = numpy.argwhere(finish_me)
        keep_me = numpy.logical_and(new_counts > 3,
                                    new_counts < counts)
        indexes_to_keep = numpy.argwhere(keep_me)
        if len(indexes_to_finish):
            result_counts[finish_me] = new_counts[finish_me]
            #
            # Store the coordinates of each of the points to finish
            #
            finish_this_row = finish_me[a[:,0]]
            rows_to_finish = numpy.argwhere(finish_this_row).flatten()
            a_to_finish = a[rows_to_finish]
            atf_indexes = a_to_finish[:,0]
            #
            # Map label #s to the index into indexes_to_finish of that label #
            #
            anti_indexes_to_finish = numpy.zeros((len(indexes),),int)
            anti_indexes_to_finish[indexes_to_finish] = range(len(indexes_to_finish))
            #
            # Figure out the indices of each point in a label to be finished.
            # We figure out how much to subtract for each label, then
            # subtract that much from 0:N to get successive indexes at
            # each label.
            # Then we add the result_index to figure out where to store it
            # in the result table.
            #
            finish_idx_base = numpy.zeros((len(indexes_to_finish),),int)
            finish_idx_base[1:]=numpy.cumsum(new_counts[indexes_to_finish])[:-1]
            finish_idx_bases = finish_idx_base[anti_indexes_to_finish[atf_indexes]]
            finish_idx = (numpy.array(range(a_to_finish.shape[0]))-
                          finish_idx_bases)
            finish_idx = finish_idx + result_index[atf_indexes]
            result[finish_idx,1:] = a_to_finish[:,1:]
        if len(indexes_to_keep) == 0:
            break
        #
        # Figure out which points are still available
        #
        rows_to_keep=numpy.argwhere(keep_me[a[:,0].astype(int)]).flatten()
        a = a[rows_to_keep]
        centers_per_point = centers_per_point[rows_to_keep]
        counts = new_counts
        #
        # The rule is that the area of the triangle from the center to
        # point N-1 to point N plus the area of the triangle from the center
        # to point N to point N+1 must be greater than the area of the
        # triangle from the center to point N-1 to point N+1 for a point
        # to be on the convex hull.
        # N-1 and N+1 have to be modulo "counts", so we make special arrays
        # to address those situations.
        #
        anti_indexes_to_keep = numpy.zeros((len(indexes),),int)
        anti_indexes_to_keep[indexes_to_keep] = range(len(indexes_to_keep))
        idx_base = numpy.zeros((len(indexes_to_keep),),int)
        idx_base[1:]=numpy.cumsum(counts[keep_me])[0:-1]
        idx_bases = idx_base[anti_indexes_to_keep[a[:,0]]]
        counts_per_pt = counts[a[:,0]]
        idx = numpy.array(range(a.shape[0]),int)-idx_bases
        n_minus_one = numpy.mod(idx+counts_per_pt-1,counts_per_pt)+idx_bases
        n_plus_one  = numpy.mod(idx+1,counts_per_pt)+idx_bases
        #
        # Compute the triangle areas
        #
        t_left = triangle_areas(centers_per_point,
                                a[n_minus_one,1:],
                                a[:,1:])
        t_right = triangle_areas(centers_per_point,
                                 a[:,1:],
                                 a[n_plus_one,1:])
        t_lr = triangle_areas(centers_per_point,
                              a[n_minus_one,1:],a[n_plus_one,1:])
        #
        # Keep the points where the area of the left triangle plus the
        # area of the right triangle is bigger than the area of the triangle
        # composed of the points to the left and right. This means that
        # there's a little triangle sitting on top of t_lr with our point
        # on top and convex in relation to its neighbors.
        #
        keep_me = t_left+t_right > t_lr
        #
        # If all points on a line are co-linear with the center, then the
        # whole line goes away. Special handling for this to find the points
        # most distant from the center and on the same side
        #
        consider_me = t_left+t_right == 0
        if numpy.any(consider_me):
            diff_i = a[:,1]-centers_per_point[:,0]
            diff_j = a[:,2]-centers_per_point[:,1]
            #
            # The manhattan distance is good enough
            #
            dist = numpy.abs(diff_i)+numpy.abs(diff_j)
            # The sign is different on different sides of a line including
            # the center. Multiply j by 2 to keep from colliding with i
            #
            # If both signs are zero, then the point is in the center
            #
            sign = numpy.sign(diff_i) + numpy.sign(diff_j)*2
            n_minus_one_consider = n_minus_one[consider_me]
            n_plus_one_consider = n_plus_one[consider_me]
            left_is_worse = numpy.logical_or(dist[consider_me] >
                                             dist[n_minus_one_consider],
                                             sign[consider_me] != 
                                             sign[n_minus_one_consider])
            right_is_worse = numpy.logical_or(dist[consider_me] >
                                              dist[n_plus_one_consider],
                                              sign[consider_me] !=
                                              sign[n_plus_one_consider])
            to_keep = numpy.logical_and(numpy.logical_and(left_is_worse,
                                                          right_is_worse),
                                        sign[consider_me] != 0)
            keep_me[consider_me] = to_keep 
        a = a[keep_me,:]
        centers_per_point = centers_per_point[keep_me]
    #
    # Finally, we have to shrink the results. We number each of the
    # points for a label, then only keep those whose indexes are
    # less than the count for their label.
    #
    within_label_index = numpy.array(range(result.shape[0]),int)
    counts_per_point = result_counts[r_anti_indexes_per_point]
    result_indexes_per_point = result_index[r_anti_indexes_per_point] 
    within_label_index = (within_label_index - result_indexes_per_point)
    result = result[within_label_index < counts_per_point]
    return result, result_counts

def triangle_areas(p1,p2,p3):
    """Compute an array of triangle areas given three arrays of triangle pts
    
    p1,p2,p3 - three Nx2 arrays of points
    """
    v1 = p2-p1
    v2 = p3-p1
    cross1 = v1[:,1] * v2[:,0]
    cross2 = v2[:,1] * v1[:,0]
    a = (cross1-cross2) / 2
    return a  

def draw_line(labels,pt0,pt1,value=1):
    """Draw a line between two points
    
    pt0, pt1 are in i,j format which is the reverse of x,y format
    Uses the Bresenham algorithm
    Some code transcribed from http://www.cs.unc.edu/~mcmillan/comp136/Lecture6/Lines.html
    """
    y0,x0 = pt0
    y1,x1 = pt1
    diff_y = abs(y1-y0)
    diff_x = abs(x1-x0)
    x = x0
    y = y0
    labels[y,x]=value
    step_x = (x1 > x0 and 1) or -1
    step_y = (y1 > y0 and 1) or -1
    if diff_y > diff_x:
        # Y varies fastest, do x before y
        remainder = diff_x*2 - diff_y
        while y != y1:
            if remainder >= 0:
                 x += step_x
                 remainder -= diff_y*2
            y += step_y
            remainder += diff_x*2
            labels[y,x] = value
    else:
        remainder = diff_y*2 - diff_x
        while x != x1:
            if remainder >= 0:
                 y += step_y
                 remainder -= diff_x*2
            x += step_x
            remainder += diff_y*2
            labels[y,x] = value

def fixup_scipy_ndimage_result(whatever_it_returned):
    """Convert a result from scipy.ndimage to a numpy array
    
    scipy.ndimage has the annoying habit of returning a single, bare
    value instead of an array if the indexes passed in are of length 1.
    For instance:
    scipy.ndimage.maximum(image, labels, [1]) returns a float
    but
    scipy.ndimage.maximum(image, labels, [1,2]) returns a list
    """
    if getattr(whatever_it_returned,"__getitem__",False):
        return numpy.array(whatever_it_returned)
    else:
        return numpy.array([whatever_it_returned])

def minimum_enclosing_circle(labels, indexes = None):
    """Find the location of the minimum enclosing circle and its radius
    
    labels - a labels matrix
    indexes - an array giving the label indexes to be processed
    
    returns an Nx3 array organized as i,j of the center and radius
    Algorithm from 
    http://www.personal.kent.edu/~rmuhamma/Compgeometry/MyCG/CG-Applets/Center/centercli.htm
    who calls it the Applet's Algorithm and ascribes it to Pr. Chrystal
    The original citation is Professor Chrystal, "On the problem to construct
    the minimum circle enclosing n given points in a plane", Proceedings of
    the Edinburgh Mathematical Society, vol 3, 1884
    """
    if indexes == None:
        max_label = numpy.max(labels)
        indexes = numpy.array(range(1,max_label+1))
    else:
        indexes = numpy.array(indexes)
    if indexes.shape[0] == 0:
        return numpy.zeros((0,2)),numpy.zeros((0,))

    hull, point_count = convex_hull(labels, indexes)
    centers = numpy.zeros((len(indexes),2))
    radii = numpy.zeros((len(indexes),))
    #
    # point_index is the index to the first point in "hull" for a label
    #
    point_index = numpy.zeros((indexes.shape[0],),int)
    point_index[1:] = numpy.cumsum(point_count[:-1]) 
    #########################################################################
    #
    # The algorithm is this:
    # * Choose a line S from S0 to S1 at random from the set of adjacent
    #   S0 and S1
    # * For every vertex (V) other than S, compute the angle from S0
    #   to V to S. If this angle is obtuse, the vertex V lies within the
    #   minimum enclosing circle and can be ignored.
    # * Find the minimum angle for all V.
    #   If the minimum angle is obtuse, stop and accept S as the diameter of 
    #   the circle.
    # * If the vertex with the minimum angle makes angles S0-S1-V and
    #   S1-S0-V that are acute and right, then take S0, S1 and V as the
    #   triangle within the circumscribed minimum enclosing circle.
    # * Otherwise, find the largest obtuse angle among S0-S1-V and
    #   S1-S0-V (V is the vertex with the minimum angle, not all of them).
    #   If S0-S1-V is obtuse, make V the new S1, otherwise make V the new S0
    #
    ##########################################################################
    #
    # anti_indexes is used to transform a label # into an index in the above array
    # anti_indexes_per_point gives the label index of any vertex
    #
    anti_indexes=numpy.zeros((numpy.max(indexes)+1,),int)
    anti_indexes[indexes] = range(indexes.shape[0])
    anti_indexes_per_point = anti_indexes[hull[:,0]]
    #
    # Start out by eliminating the degenerate cases: 0, 1 and 2
    #
    centers[point_count==0,:]= numpy.NaN
    if numpy.all(point_count == 0):
        # Bail if there are no points in any hull to prevent
        # index failures below.
        return centers,radii
        
    centers[point_count==1,:]=hull[point_index[point_count==1],1:]
    radii[point_count < 2]=0
    centers[point_count==2,:]=(hull[point_index[point_count==2],1:]+
                               hull[point_index[point_count==2]+1,1:])/2
    distance = centers[point_count==2,:] - hull[point_index[point_count==2],1:]
    radii[point_count==2]=numpy.sqrt(distance[:,0]**2+distance[:,1]**2)
    #
    # Get rid of the degenerate points
    #
    keep_me = point_count > 2
    #
    # Pick S0 as the first point in each label
    # and S1 as the second.
    #
    s0_idx = point_index.copy()
    s1_idx = s0_idx+1
    #
    # number each of the points in a label with an index # which gives
    # the order in which we'll get their angles. We use this to pick out
    # points # 2 to N which are the candidate vertices to S
    # 
    within_label_indexes = (numpy.array(range(hull.shape[0]),int) -
                            point_index[anti_indexes_per_point])
    
    while(numpy.any(keep_me)):
        #############################################################
        # Label indexing for active labels
        #############################################################
        #
        # labels_to_consider contains the labels of the objects which
        # have not been completed
        #
        labels_to_consider = indexes[keep_me]
        #
        # anti_indexes_to_consider gives the index into any vector
        # shaped similarly to labels_to_consider (for instance, min_angle
        # below) for every label in labels_to_consider.
        #
        anti_indexes_to_consider =\
            numpy.zeros((numpy.max(labels_to_consider)+1,),int)
        anti_indexes_to_consider[labels_to_consider] = \
            numpy.array(range(labels_to_consider.shape[0]))
        ##############################################################
        # Vertex indexing for active vertexes other than S0 and S1
        ##############################################################
        #
        # The vertices are hull-points with indexes of 2 or more
        # keep_me_vertices is a mask of the vertices to operate on
        # during this iteration
        #
        keep_me_vertices = numpy.logical_and(keep_me[anti_indexes_per_point],
                                             within_label_indexes >= 2)
        #
        # v is the vertex coordinates for each vertex considered
        #
        v  = hull[keep_me_vertices,1:]
        #
        # v_labels is the label from the label matrix for each vertex
        #
        v_labels = hull[keep_me_vertices,0]
        #
        # v_indexes is the index into "hull" for each vertex (and similarly
        # shaped vectors such as within_label_indexes
        #
        v_indexes=numpy.argwhere(keep_me_vertices).flatten()
        #
        # anti_indexes_per_vertex gives the index into "indexes" and
        # any similarly shaped array of per-label values
        # (for instance s0_idx) for each vertex being considered
        #
        anti_indexes_per_vertex = anti_indexes_per_point[keep_me_vertices]
        #
        # anti_indexes_to_consider_per_vertex gives the index into any
        # vector shaped similarly to labels_to_consider for each
        # vertex being analyzed
        #
        anti_indexes_to_consider_per_vertex = anti_indexes_to_consider[v_labels]
        #
        # Get S0 and S1 per vertex
        #
        s0 = hull[s0_idx[keep_me],1:]
        s1 = hull[s1_idx[keep_me],1:]
        s0 = s0[anti_indexes_to_consider_per_vertex]
        s1 = s1[anti_indexes_to_consider_per_vertex]
        #
        # Compute the angle S0-S1-V
        #
        # the first vector of the angles is between S0 and S1
        #
        s01 = (s0 - s1).astype(float)
        #
        # compute V-S1 and V-S0 at each of the vertices to be considered
        #
        vs0 = (v - s0).astype(float)
        vs1 = (v - s1).astype(float) 
        #
        #` Take the dot product of s01 and vs1 divided by the length of s01 *
        # the length of vs1. This gives the cosine of the angle between.
        #
        dot_vs1s0 = (numpy.sum(s01*vs1,1) /
                     numpy.sqrt(numpy.sum(s01**2,1)*numpy.sum(vs1**2,1)))
        angle_vs1s0 = numpy.abs(numpy.arccos(dot_vs1s0))
        s10 = -s01
        dot_vs0s1 = (numpy.sum(s10*vs0,1) /
                     numpy.sqrt(numpy.sum(s01**2,1)*numpy.sum(vs0**2,1)))
        angle_vs0s1 = numpy.abs(numpy.arccos(dot_vs0s1))
        #
        # S0-V-S1 is pi - the other two
        #
        angle_s0vs1 = numpy.pi - angle_vs1s0 - angle_vs0s1
        assert numpy.all(angle_s0vs1 >= 0)
        #
        # Now we find the minimum angle per label
        #
        min_angle = scipy.ndimage.minimum(angle_s0vs1,v_labels,
                                          labels_to_consider)
        min_angle = fixup_scipy_ndimage_result(min_angle)
        min_angle_per_vertex = min_angle[anti_indexes_to_consider_per_vertex]
        #
        # Calculate the index into V of the minimum angle per label.
        # Use "indexes" instead of labels_to_consider so we get something
        # with the same shape as keep_me
        #
        min_position = scipy.ndimage.minimum_position(angle_s0vs1,v_labels,
                                                      indexes)
        min_position = fixup_scipy_ndimage_result(min_position)
        min_position = min_position.flatten()
        #
        # Case 1: minimum angle is obtuse or right. Accept S as the diameter.
        # Case 1a: there are no vertices. Accept S as the diameter.
        #
        vertex_counts = scipy.ndimage.sum(keep_me_vertices,
                                          hull[:,0],
                                          labels_to_consider)
        vertex_counts = fixup_scipy_ndimage_result(vertex_counts)
        case_1 = numpy.logical_or(min_angle >= numpy.pi / 2,
                                  vertex_counts == 0)
                                   
        if numpy.any(case_1):
            # convert from a boolean over indexes_to_consider to a boolean
            # over indexes
            finish_me = numpy.zeros((indexes.shape[0],),bool)
            finish_me[anti_indexes[labels_to_consider[case_1]]] = True
            s0_finish_me = hull[s0_idx[finish_me],1:].astype(float)
            s1_finish_me = hull[s1_idx[finish_me],1:].astype(float)
            centers[finish_me] = (s0_finish_me + s1_finish_me)/2
            radii[finish_me] = numpy.sqrt(numpy.sum((s0_finish_me - 
                                                     s1_finish_me)**2,1))/2
            keep_me[finish_me] = False
        #
        # Case 2: all angles for the minimum angle vertex are acute 
        #         or right.
        #         Pick S0, S1 and the vertex with the
        #         smallest angle as 3 points on the circle. If you look at the
        #         geometry, the diameter is the length of S0-S1 divided by
        #         the cosine of 1/2 of the angle. The center of the circle
        #         is at the circumcenter of the triangle formed by S0, S1 and
        #         V.
        case_2 = keep_me.copy()
        case_2[angle_vs1s0[min_position] > numpy.pi/2] = False
        case_2[angle_vs0s1[min_position] > numpy.pi/2] = False
        case_2[angle_s0vs1[min_position] > numpy.pi/2] = False
        
        if numpy.any(case_2):
            #
            # Wikipedia (http://en.wikipedia.org/wiki/Circumcircle#Cartesian_coordinates)
            # gives the following:
            # D = 2(S0y Vx + S1y S0x - S1y Vx - S0y S1x - S0x Vy + S1x Vy)
            # D = 2(S0x (S1y-Vy) + S1x(Vy-S0y) + Vx(S0y-S1y)
            # x = ((S0x**2+S0y**2)(S1y-Vy)+(S1x**2+S1y**2)(Vy-S0y)+(Vx**2+Vy**2)(S0y-S1y)) / D
            # y = ((S0x**2+S0y**2)(Vx-S1x)+(S1x**2+S1y**2)(S0y-Vy)+(Vx**2+Vy**2)(S1y-S0y)) / D
            #
            ss0 = hull[s0_idx[case_2],1:].astype(float)
            ss1 = hull[s1_idx[case_2],1:].astype(float)
            vv  = v[min_position[case_2]].astype(float)
            Y = 0
            X = 1 
            D = 2*(ss0[:,X] * (ss1[:,Y] - vv[:,Y]) +
                   ss1[:,X] * (vv[:,Y]  - ss0[:,Y]) +
                   vv[:,X]  * (ss0[:,Y] - ss1[:,Y]))
            x = (numpy.sum(ss0**2,1)*(ss1[:,Y] - vv[:,Y]) +
                 numpy.sum(ss1**2,1)*(vv[:,Y]  - ss0[:,Y]) +
                 numpy.sum(vv**2,1) *(ss0[:,Y] - ss1[:,Y])) / D
            y = (numpy.sum(ss0**2,1)*(vv[:,X]  - ss1[:,X]) +
                 numpy.sum(ss1**2,1)*(ss0[:,X] - vv[:,X]) +
                 numpy.sum(vv**2,1) *(ss1[:,X] - ss0[:,X])) / D
            centers[case_2,X] = x
            centers[case_2,Y] = y
            distances = ss0-centers[case_2]
            radii[case_2] = numpy.sqrt(numpy.sum(distances**2,1))
            keep_me[case_2] = False
        #
        # Finally, for anybody who's left, for each of S0-S1-V and
        # S1-S0-V, for V, the vertex with the minimum angle,
        # find the largest obtuse angle. The vertex of this
        # angle (S0 or S1) is inside the enclosing circle, so take V
        # and either S1 or S0 as the new S.
        #
        # This involves a relabeling of within_label_indexes. We replace
        # either S0 or S1 with V and assign V either 0 or 1
        #
        if numpy.any(keep_me):
            labels_to_consider = indexes[keep_me]
            indexes_to_consider = anti_indexes[labels_to_consider]
            #
            # Index into within_label_indexes for each V with the
            # smallest angle
            #
            v_obtuse_indexes = v_indexes[min_position[keep_me]]
            angle_vs0s1_to_consider = angle_vs0s1[min_position[keep_me]]
            angle_vs1s0_to_consider = angle_vs1s0[min_position[keep_me]]
            #
            # Do the cases where S0 is larger
            #
            s0_is_obtuse = angle_vs0s1_to_consider > numpy.pi/2
            if numpy.any(s0_is_obtuse):
                #
                # The index of the obtuse S0
                #
                v_obtuse_s0_indexes = v_obtuse_indexes[s0_is_obtuse]
                obtuse_s0_idx = s0_idx[indexes_to_consider[s0_is_obtuse]]
                #
                # S0 gets the within_label_index of the vertex
                #
                within_label_indexes[obtuse_s0_idx] = \
                    within_label_indexes[v_obtuse_s0_indexes]
                #
                # Assign V as the new S0
                #
                s0_idx[indexes_to_consider[s0_is_obtuse]] = v_obtuse_s0_indexes
                within_label_indexes[v_obtuse_s0_indexes] = 0
            #
            # Do the cases where S1 is larger
            #
            s1_is_obtuse = numpy.logical_not(s0_is_obtuse)
            if numpy.any(s1_is_obtuse):
                #
                # The index of the obtuse S1
                #
                v_obtuse_s1_indexes = v_obtuse_indexes[s1_is_obtuse]
                obtuse_s1_idx = s1_idx[indexes_to_consider[s1_is_obtuse]]
                #
                # S1 gets V's within_label_index and goes onto the list
                # of considered vertices.
                #
                within_label_indexes[obtuse_s1_idx] = \
                    within_label_indexes[v_obtuse_s1_indexes]
                #
                # Assign V as the new S1
                #
                s1_idx[indexes_to_consider[s1_is_obtuse]] = v_obtuse_s1_indexes
                within_label_indexes[v_obtuse_s1_indexes] = 1
    return centers, radii

def ellipse_from_second_moments(image, labels, indexes):
    """Calculate measurements of ellipses equivalent to the second moments of labels
    
    image  - the intensity at each point
    labels - for each labeled object, derive an ellipse
    indexes - sequence of indexes to process
    
    returns the following arrays:
       coordinates of the center of the ellipse
       eccentricity
       major axis length
       minor axis length
       orientation
    
    some definitions taken from "Image Moments-Based Structuring and Tracking
    of Objects", LOURENA ROCHA, LUIZ VELHO, PAULO CEZAR P. CARVALHO,
    http://sibgrapi.sid.inpe.br/col/sid.inpe.br/banon/2002/10.23.11.34/doc/35.pdf
    particularly equation 5 (which has some errors in it).
    These yield the rectangle with equivalent second moments. I translate
    to the ellipse by multiplying by 1.154701 which is Matlab's calculation
    of the major and minor axis length for a square of length X divided
    by the actual length of the side of a square of that length.
    
    eccentricity is the distance between foci divided by the major axis length
    orientation is the angle of the major axis with respect to the X axis
    """
    if len(indexes) == 0:
        return numpy.zeros((0,2)),numpy.zeros((0,)),numpy.zeros((0,)),numpy.zeros((0,))
    i,j = numpy.mgrid[0:labels.shape[0],0:labels.shape[1]]
    #
    # Start by calculating the moments m[p][q] of the image
    # sum(i**p j**q)
    #
    fix = fixup_scipy_ndimage_result
    m = {}
    m[0,0] = fix(scipy.ndimage.sum(image,    labels, indexes))
    m[1,0] = fix(scipy.ndimage.sum(i*image,  labels, indexes))
    m[0,1] = fix(scipy.ndimage.sum(j*image,  labels, indexes))
    m[1,1] = fix(scipy.ndimage.sum(i*j*image,labels, indexes))
    m[2,0] = fix(scipy.ndimage.sum(i*i*image,labels, indexes))
    m[0,2] = fix(scipy.ndimage.sum(j*j*image,labels, indexes))
    
    ic = m[1,0] / m[0,0]
    jc = m[0,1] / m[0,0]
    
    a = m[2,0] / m[0,0] - ic**2
    b = 2*(m[1,1]/m[0,0] - ic * jc)
    c = m[0,2] / m[0,0] - jc**2
    
    theta = numpy.arctan2(b,c-a) / 2
    temp = numpy.sqrt(4*b**2+(a-c)**2)
    #
    # If you do a linear regression of the circles from 1 to 50 radius
    # in Matlab, the resultant values fit a line with slope=.9975 and
    # intercept .095. I'm adjusting the lengths accordingly.
    #
    mystery_constant = 0.095
    mystery_multiplier = 0.9975
    major_axis_len = (numpy.sqrt(8*(a+c+temp)) * mystery_multiplier +
                      mystery_constant)
    minor_axis_len = (numpy.sqrt(8*(a+c-temp)) * mystery_multiplier +
                      mystery_constant)
    eccentricity = numpy.sqrt(1-(minor_axis_len / major_axis_len)**2) 
    return (numpy.dstack((ic,jc))[0,:,:],
            eccentricity,
            major_axis_len,
            minor_axis_len,theta)

def calculate_extents(labels, indexes):
    """Return the area of each object divided by the area of its bounding box"""
    areas = scipy.ndimage.sum(labels,labels,indexes)
    y,x = numpy.mgrid[0:labels.shape[0],0:labels.shape[1]]
    xmin = scipy.ndimage.minimum(x, labels, indexes)
    xmax = scipy.ndimage.maximum(x, labels, indexes)
    ymin = scipy.ndimage.minimum(y, labels, indexes)
    ymax = scipy.ndimage.maximum(y, labels, indexes)
    bbareas = (xmax-xmin+1)*(ymax-ymin+1)
    return areas / bbareas

# The perimeter scoring matrix provides the distance to the next point
#    
#   To use this, the value at [i-1,j-1] is bit 0, [i-1,j] is bit 1, [i-1,j+1]
#   is bit 2, etc. of an index into the perimeter_scoring
#   the distance from the center point to the next point clockwise on the
#   perimeter. The values must be the label matrix == shifted label matrix
#    
#   I came up with the idea for this independently, but while Googling,
#   found a reference to the same idea. The perimeter matrix is taken from
#   the reference:
#   Prashker, "An Improved Algorithm for Calculating the Perimeter and Area 
#   of Raster Polygons", GeoComputation 99.
#    http://www.geovista.psu.edu/sites/geocomp99/Gc99/076/gc_076.htm 
def __calculate_perimeter_scoring():
    """Return a 512 element vector which gives the perimeter given surrounding pts
    
    """
    #
    # This is the array from the paper - a 256 - element array leaving out
    # the center point. The first value is the index, the second, the perimeter
    #
    prashker = numpy.array([                                                        
        [0 ,4    ],[32,4    ],[64,3    ],[96 ,1.414],[128,4    ],[160,4    ],[192,1.414],[224,2.828],
        [1 ,4    ],[33,4    ],[65,3    ],[97 ,1.414],[129,4    ],[161,4    ],[193,3    ],[225,3    ],
        [2 ,3    ],[34,3    ],[66,2    ],[98 ,2    ],[130,3    ],[162,3    ],[194,2    ],[226,2    ],
        [3 ,1.414],[35,1.414],[67,2    ],[99 ,2    ],[131,3    ],[163,3    ],[195,2    ],[227,2    ],
        [4 ,4    ],[36,4    ],[68,3    ],[100,3    ],[132,4    ],[164,4    ],[196,1.414],[228,3    ],
        [5 ,4    ],[37,4    ],[69,3    ],[101,3    ],[133,4    ],[165,4    ],[197,3    ],[229,3    ],
        [6 ,1.414],[38,3    ],[70,2    ],[102,2    ],[134,1.414],[166,3    ],[198,2    ],[230,2    ],
        [7 ,2.828],[39,3    ],[71,2    ],[103,2    ],[135,3    ],[167,3    ],[199,2    ],[231,1.414],
        [8 ,3    ],[40,1.414],[72,2    ],[104,2    ],[136,3    ],[168,1.414],[200,1.414],[232,1.414],
        [9 ,1.414],[41,2.828],[73,1.414],[105,1.414],[137,3    ],[169,3    ],[201,1.414],[233,1.414],
        [10,2    ],[42,1.414],[74,1    ],[106,1    ],[138,2    ],[170,2    ],[202,1    ],[234,1.414],
        [11,2    ],[43,1.414],[75,1    ],[107,1    ],[139,2    ],[171,2    ],[203,1    ],[235,1    ],
        [12,3    ],[44,3    ],[76,2    ],[108,2    ],[140,3    ],[172,3    ],[204,2    ],[236,2    ],
        [13,1.414],[45,3    ],[77,2    ],[109,2    ],[141,3    ],[173,3    ],[205,1.414],[237,1.414],
        [14,1.414],[46,1.414],[78,1    ],[110,1    ],[142,2    ],[174,1.414],[206,2    ],[238,1    ],
        [15,1.414],[47,1.414],[79,1.414],[111,1    ],[143,2    ],[175,1.414],[207,1    ],[239,1    ],
        [16,3    ],[48,3    ],[80,2    ],[112,1.414],[144,1.414],[176,1.414],[208,2    ],[240,1.414],
        [17,3    ],[49,3    ],[81,2    ],[113,2    ],[145,3    ],[177,3    ],[209,2    ],[241,2    ],
        [18,2    ],[50,2    ],[82,1    ],[114,1    ],[146,1.414],[178,2    ],[210,1    ],[242,1.414],
        [19,1.414],[51,2    ],[83,1    ],[115,2    ],[147,1.414],[179,1.414],[211,1    ],[243,1    ],
        [20,1.414],[52,3    ],[84,1.414],[116,1.414],[148,2.828],[180,3    ],[212,1.414],[244,1.414],
        [21,1.414],[53,3    ],[85,2    ],[117,1.414],[149,3    ],[181,3    ],[213,2    ],[245,1.414],
        [22,2    ],[54,2    ],[86,1    ],[118,1    ],[150,1.414],[182,2    ],[214,1    ],[246,1    ],
        [23,1.414],[55,2    ],[87,1.414],[119,1    ],[151,1.414],[183,1.414],[215,1    ],[247,1    ],
        [24,2    ],[56,2    ],[88,1    ],[120,1    ],[152,2    ],[184,2    ],[216,1    ],[248,1    ],
        [25,2    ],[57,2    ],[89,1    ],[121,1.414],[153,2    ],[185,2    ],[217,1    ],[249,1    ],
        [26,1    ],[58,1    ],[90,0    ],[122,0    ],[154,1    ],[186,2    ],[218,0    ],[250,0    ],
        [27,1    ],[59,1.414],[91,0    ],[123,0    ],[155,1    ],[187,1    ],[219,0    ],[251,0    ],
        [28,2    ],[60,2    ],[92,1    ],[124,1    ],[156,2    ],[188,2    ],[220,1.414],[252,1    ],
        [29,2    ],[61,2    ],[93,2    ],[125,1    ],[157,2    ],[189,1.414],[221,1    ],[253,1    ],
        [30,1    ],[62,1    ],[94,0    ],[126,0    ],[158,1.414],[190,1    ],[222,0    ],[254,0    ],
        [31,1    ],[63,1    ],[95,0    ],[127,0    ],[159,1    ],[191,1    ],[223,0    ],[255,0]])
    score = numpy.zeros((512,))
    i = numpy.zeros((prashker.shape[0]),int)
    for j in range(4): # 1,2,4,8
        i = i+((prashker[:,0].astype(int) / 2**j)%2)*2**j
    i = i+16
    for j in range(4,8):
        i = i+((prashker[:,0].astype(int) / 2**j)%2)*2**(j+1)
    score[i.astype(int)] = prashker[:,1]
    return score

__perimeter_scoring = __calculate_perimeter_scoring()

def calculate_perimeters(labels, indexes):
    """Count the distances between adjacent pixels in the perimeters of the labels"""
    #
    # Create arrays that tell whether a pixel is like its neighbors.
    # index = 0 is the pixel -1,-1 from the pixel of interest, 1 is -1,0, etc.
    #
    m=numpy.zeros((labels.shape[0],labels.shape[1]),int)
    exponent = 0
    for i in range(-1,2):
        ilow = (i==-1 and 1) or 1
        iend = (i==1 and labels.shape[0]-1) or labels.shape[0] 
        for j in range(-1,2):
            jlow = (j==-1 and 1) or 1
            jend = (j==1 and labels.shape[0]-1) or labels.shape[0] 
            m[ilow:iend,jlow:jend] = \
                (m[ilow:iend,jlow:jend] +
                 (labels[ilow:iend,jlow:jend] == 
                  labels[ilow+i:iend+i,jlow+j:jend+j])*2**exponent)
            exponent += 1
    pixel_score = __perimeter_scoring[m]
    return scipy.ndimage.sum(pixel_score, labels, indexes)

def calculate_convex_hull_areas(labels,indexes=None):
    """Calulculate the area of the convex hull of each labeled object
    
    labels - a label matrix
    indexes - None: calculate convex hull area over entire image
              number: calculate convex hull for a single label
              sequence: calculate convex hull for labels matching a sequence
                        member and return areas in same order.
    """
    if getattr(indexes,"__getitem__",False):
        indexes = numpy.array(indexes)
    elif indexes != None:
        indexes = numpy.array([indexes])
    else:
        labels = labels !=0
        indexes = numpy.array([1])
    hull, counts = convex_hull(labels, indexes)
    result = numpy.zeros((counts.shape[0],))
    #
    # Get rid of the degenerate cases
    #
    result[counts==1] = 1 # a single point has area 1
    if not numpy.any(counts >1):
        return result
    #
    # Given a label number "index_of_label" indexes into the result
    #
    index_of_label = numpy.zeros((hull[:,0].max()+1),int)
    index_of_label[indexes] = numpy.array(range(indexes.shape[0]))
    #
    # hull_index is the index into hull of the first point on the hull
    # per label
    #
    hull_index = numpy.zeros((counts.shape[0],),int)
    hull_index[1:] = numpy.cumsum(counts[:-1])
    #
    # A 2-point case is a line. The area of a line is its length * 1
    # and its length needs to be expanded by 1 because the end-points are
    # at the limits, not the ends.
    # 
    if numpy.any(counts==2):
        diff_2 = hull[hull_index[counts==2],1:]-hull[hull_index[counts==2]+1,1:]
        result[counts==2] = numpy.sqrt(numpy.sum(diff_2**2))+1
    if not numpy.any(counts>=3):
        return result
    #
    # Now do the non-degenerate cases (_nd)
    #
    counts_per_label = numpy.zeros((hull[:,0].max()+1),counts.dtype)
    counts_per_label[indexes] = counts
    hull_nd = hull[counts_per_label[hull[:,0]] >=3]
    counts_nd = counts[counts>=3]
    indexes_nd = indexes[counts>=3]
    index_of_label_nd = numpy.zeros((index_of_label.shape[0],),int)
    index_of_label_nd[indexes_nd] = numpy.array(range(indexes_nd.shape[0]))
    #
    # Figure out the within-label index of each point in a label. This is
    # so we can do modulo arithmetic when pairing a point with the next
    # when determining an edge
    #
    hull_index_nd = numpy.zeros((counts_nd.shape[0],),int)
    if hull_index_nd.shape[0] > 1:
        hull_index_nd[1:] = numpy.cumsum(counts_nd[:-1])
    index_of_label_per_pixel_nd = index_of_label_nd[hull_nd[:,0]]
    hull_index_per_pixel_nd = hull_index_nd[index_of_label_per_pixel_nd] 
    within_label_index = (numpy.array(range(hull_nd.shape[0])) -
                          hull_index_per_pixel_nd)
    #
    # Find some point within each convex hull.
    #
    within_hull = numpy.zeros((counts_nd.shape[0],2))
    within_hull[:,0] = scipy.ndimage.sum(hull_nd[:,1],
                                         hull_nd[:,0],
                                         indexes_nd) / counts_nd
    within_hull[:,1] = scipy.ndimage.sum(hull_nd[:,2],
                                         hull_nd[:,0],
                                         indexes_nd) / counts_nd
    within_hull_per_pixel = within_hull[index_of_label_per_pixel_nd]
    #
    # Now, we do a little, slightly wierd fixup, arguing that the
    # edge of a pixel is +/- .5 of its coordinate. So we move the ones
    # left of center to the left by .5, right of center to the right by .5
    # etc.
    #
    # It works for a square...
    #
    hull_nd[hull_nd[:,1] < within_hull_per_pixel[:,0],1]  -= .5
    hull_nd[hull_nd[:,2] < within_hull_per_pixel[:,1],2]  -= .5
    hull_nd[hull_nd[:,1] >= within_hull_per_pixel[:,0],1] += .5
    hull_nd[hull_nd[:,2] >= within_hull_per_pixel[:,1],2] += .5
    #
    # Finally, we go around the circle, computing triangle areas
    # from point n to point n+1 (modulo count) to the point within
    # the hull.
    #
    plus_one_idx = numpy.array(range(hull_nd.shape[0]))+1
    modulo_mask = within_label_index+1 == counts_nd[index_of_label_per_pixel_nd]
    plus_one_idx[modulo_mask] = hull_index_per_pixel_nd[modulo_mask]
    area_per_pt_nd = triangle_areas(hull_nd[:,1:],
                                    hull_nd[plus_one_idx,1:],
                                    within_hull_per_pixel)
    #
    # The convex area is the sum of these triangles
    #
    result[counts>=3] = scipy.ndimage.sum(area_per_pt_nd,
                                          hull_nd[:,0],
                                          indexes_nd)
    return result

def calculate_solidity(labels,indexes=None):
    """Calculate the area of each label divided by the area of its convex hull
    
    labels - a label matrix
    indexes - the indexes of the labels to measure
    """
    areas = scipy.ndimage.sum(numpy.ones(labels.shape),labels,indexes)
    convex_hull_areas = calculate_convex_hull_areas(labels, indexes)
    return areas / convex_hull_areas
