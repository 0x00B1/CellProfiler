""" cpmorphology.py - morphological operations not in scipy

"""
__version__="$Revision: 1 "

import numpy
import scipy.ndimage
import scipy.sparse
import _cpmorphology
from outline import outline 

def fill_labeled_holes(image):
    """Fill holes in objects in a labeled image
    
    image - a label matrix, for instance as generated by scipy.ndimage.label
    This algorithm takes a labeled image and fills any hole (unlabeled 
    pixels surrounded solely by one label). The key insight is that if
    you generate a binary image composed of the unlabeled points and
    you label it, each hole gets a unique label. After that, you can get
    rid of any labeled "hole" that's touching the border and any labeled
    "hole" that's touching more than one labeled object (space between two
    touching objects). A further trick is to figure out whether a hole
    touches more than one object or the edge. To get the min and the max,
    ignoring the holes, we label the holes as zero in the labeled image
    for the max (already done) and label them with infinity (more or less)
    when doing the min. Finally, we can get rid of the "holes" touching
    the border by labeling the border with zero (by choosing a mode of
    "constant" and a cval of zero) so that their min will differ from
    the maximum object they touch.
    
    If you 8-connect objects, then you must 4-connect the holes to
    keep holes like the following from connecting with the outside world:
    * 1 *
    1 @ 1
    * 1 *
    where * is outside background, @ is inside background and 1 is foreground.
    """
    four_connect = scipy.ndimage.generate_binary_structure(2, 1)
    negative_mask = (image == 0)
    labeled_holes, nholes = scipy.ndimage.label(negative_mask,four_connect)
    high = image.max()+1
    image_with_high_holes = image.copy()
    image_with_high_holes[labeled_holes > 0] = high
    min_label = scipy.ndimage.minimum_filter(image_with_high_holes,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    max_label = scipy.ndimage.maximum_filter(image,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    min_label_per_hole = scipy.ndimage.minimum(min_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = scipy.ndimage.maximum(max_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = numpy.array(max_label_per_hole)
    hole_label = numpy.array(min_label_per_hole)
    hole_label[hole_label != max_label_per_hole] = 0
    hole_mask = hole_label[labeled_holes] > 0
    output_image = image.copy()
    output_image[hole_mask] = hole_label[labeled_holes[hole_mask]]
    return output_image

def binary_thin(image, strel1, strel2):
    """Morphologically thin an image
    strel1 - the required values of the pixels in order to survive
    strel2 - at each pixel, the complement of strel1 if we care about the value
    """
    hit_or_miss = scipy.ndimage.binary_hit_or_miss(image, strel1, strel2)
    return numpy.logical_and(image,numpy.logical_not(hit_or_miss))

def binary_shrink(image, iterations=-1):
    """Shrink an image by repeatedly removing pixels which have partners
       above, to the left, to the right and below until the image doesn't change
       
       image - binary image to be manipulated
       iterations - # of times to shrink, -1 to shrink until idempotent
       
       There are horizontal/vertical thinners which detect a pixel on
       an edge with an interior pixel either horizontally or vertically
       attached like this:
       0  0  0
       X  1  X
       X  1  X
       and there are much more specific diagonal thinners which detect
       a pixel on the edge of a diagonal, like this:
       0  0  0
       0  1  0
       0  0  1
       Rotate each of these 4x to get the four directions for each
    """
    hv_thinner = numpy.array([[False,False,False],[False,True,False],[False,True,False]])
    hv_anti_thinner = numpy.array([[True,True,True],[False,False,False],[False,False,False]])
    d_thinner = numpy.array([[False,False,False],[False,True,False],[False,False,True]])
    d_anti_thinner = numpy.array([[True,True,True],[True,False,True],[True,True,False]])
    thinners = []
    anti_thinners = []
    for thinner,anti_thinner in ((hv_thinner, hv_anti_thinner),(d_thinner,d_anti_thinner)):
        for n in range(4):
            thinners.append(numpy.lib.rot90(thinner,n))
            anti_thinners.append(numpy.lib.rot90(anti_thinner,n))
    if iterations == -1:
        iterations = 10000
    result = image
    for n in range(iterations):
        temp = result.copy()
        for thinner,anti_thinner in zip(thinners,anti_thinners):
            temp = binary_thin(temp,thinner,anti_thinner)
        if numpy.all(temp==result):
            return result
        result=temp

def strel_disk(radius):
    """Create a disk structuring element for morphological operations
    
    radius - radius of the disk
    """
    iradius = int(radius)
    x,y     = numpy.mgrid[-iradius:iradius+1,-iradius:iradius+1]
    radius2 = radius * radius
    strel   = numpy.zeros(x.shape)
    strel[x*x+y*y <= radius2] = 1
    return strel

def cpmaximum(image, structure=numpy.ones((3,3),dtype=bool),offset=None):
    """Find the local maximum at each point in the image, using the given structuring element
    
    image - a 2-d array of doubles
    structure - a boolean structuring element indicating which
                local elements should be sampled
    offset - the offset to the center of the structuring element
    """
    if not offset:
        offset = (structure.shape[0]/2,structure.shape[1]/2)
    offset = tuple(offset)
    return _cpmorphology.cpmaximum(image,structure,offset)

def relabel(image):
    """Given a labeled image, relabel each of the objects consecutively
    
    image - a labeled 2-d integer array
    returns - (labeled image, object count) 
    """
    #
    # Build a label table that converts an old label # into
    # labels using the new numbering scheme
    #
    unique_labels = numpy.unique(image)
    consecutive_labels = numpy.array(range(len(unique_labels)+1))
    label_table = numpy.ndarray(((unique_labels[-1]+1),),int)
    for old,new in zip(unique_labels,consecutive_labels):
        label_table[old]=new
    #
    # Use the label table to remap all of the labels
    #
    new_image = label_table[image]
    return (new_image,len(unique_labels)-1)

def convex_hull(labels, indexes=None):
    """Given a labeled image, return a list of points per object ordered by
    angle from an interior point, representing the convex hull.
    
    labels - the label matrix
    indexes - an array of label #s to be processed, defaults to all non-zero
              labels
    
    Returns a matrix and a vector. The matrix consists of one row per
    point in the convex hull. Each row has three columns, the label #,
    the i coordinate of the point and the j coordinate of the point. The
    result is organized first by label, then the points are arranged
    counter-clockwise around the perimeter.
    The vector is a vector of #s of points in the convex hull per label
    """
    if indexes == None:
        indexes = numpy.unique(labels)
        indexes.sort()
        indexes=indexes[indexes!=0]
    else:
        indexes=numpy.array(indexes)
    if len(indexes) == 0:
        return numpy.zeros((0,2),int),numpy.zeros((0,),int)
    #
    # An array that converts from label # to index in "indexes"
    anti_indexes = numpy.zeros((numpy.max(indexes)+1,),int)
    anti_indexes[indexes] = range(len(indexes))
    #
    # Reduce the # of points to consider
    #
    outlines = outline(labels)
    centers  = scipy.ndimage.center_of_mass(outlines,outlines, indexes)
    centers = numpy.array([centers])
    centers.shape=(indexes.shape[0],2) # if max_label = 1, you get 1d array
    #
    # Now make an array with one outline point per row and the following
    # columns:
    #
    # index of label # in indexes array
    # angle of the point relative to the center
    # i coordinate of the point
    # j coordinate of the point
    #
    coords = numpy.argwhere(outlines > 0)
    if len(coords)==0:
        # Every outline of every image is blank
        return (numpy.zeros((0,3),int),
                numpy.zeros((len(indexes),),int))
    
    i = coords[:,0]
    j = coords[:,1]
    labels_per_point = labels[i,j]
    anti_indexes_per_point = anti_indexes[labels_per_point]
    centers_per_point = centers[anti_indexes_per_point]
    angle = numpy.arctan2(i-centers_per_point[:,0],j-centers_per_point[:,1])
    a = numpy.zeros((len(i),3),int)
    a[:,0] = anti_indexes_per_point
    a[:,1:] = coords
    #
    # Sort the array first by label # (sort of), then by angle
    #
    order = numpy.lexsort((angle,anti_indexes_per_point))
    a=a[order]
    anti_indexes_per_point = anti_indexes_per_point[order]
    #
    # Make the result matrix, leaving enough space so that all points might
    # be on the convex hull.
    #
    result = numpy.zeros((len(i),3),int)
    result[:,0] = labels_per_point[order]
    #
    # Create an initial count vector
    #
    v = numpy.ones((a.shape[0],),dtype=int)
    result_counts = scipy.sparse.coo_matrix((v,(a[:,0],v*0)),
                                            shape=(len(indexes),1))
    result_counts = result_counts.toarray().flatten()
    r_anti_indexes_per_point = anti_indexes_per_point # save this
    #
    # Create a vector that indexes into the results for each label
    #
    result_index = numpy.zeros(result_counts.shape,int)
    result_index[1:]=numpy.cumsum(result_counts[:-1])
    #
    # Initialize the counts of convex hull points to a ridiculous number
    #
    counts = numpy.ones((len(indexes),),int) * (numpy.product(labels.shape)+1)
    while True:
        #
        # Figure out how many putative convex hull points there are for
        # each label.
        #
        # If the count for a label is 3 or less, it's a convex hull or
        # degenerate case.
        #
        # If the count hasn't changed in an iteration, then we've done
        # as well as we can hope to do.
        #
        v = numpy.ones((a.shape[0],),dtype=int)
        new_counts = scipy.sparse.coo_matrix((v,(a[:,0],v*0)),
                                             shape=(len(indexes),1))
        new_counts = new_counts.toarray().flatten()
        finish_me = numpy.logical_and(new_counts > 0,
                                      numpy.logical_or(new_counts <= 3,
                                                       new_counts == counts))
        indexes_to_finish = numpy.argwhere(finish_me)
        keep_me = numpy.logical_and(new_counts > 3,
                                    new_counts < counts)
        indexes_to_keep = numpy.argwhere(keep_me)
        if len(indexes_to_finish):
            result_counts[finish_me] = new_counts[finish_me]
            #
            # Store the coordinates of each of the points to finish
            #
            finish_this_row = finish_me[a[:,0]]
            rows_to_finish = numpy.argwhere(finish_this_row).flatten()
            a_to_finish = a[rows_to_finish]
            atf_indexes = a_to_finish[:,0]
            #
            # Map label #s to the index into indexes_to_finish of that label #
            #
            anti_indexes_to_finish = numpy.zeros((len(indexes),),int)
            anti_indexes_to_finish[indexes_to_finish] = range(len(indexes_to_finish))
            #
            # Figure out the indices of each point in a label to be finished.
            # We figure out how much to subtract for each label, then
            # subtract that much from 0:N to get successive indexes at
            # each label.
            # Then we add the result_index to figure out where to store it
            # in the result table.
            #
            finish_idx_base = numpy.zeros((len(indexes_to_finish),),int)
            finish_idx_base[1:]=numpy.cumsum(new_counts[indexes_to_finish])[:-1]
            finish_idx_bases = finish_idx_base[anti_indexes_to_finish[atf_indexes]]
            finish_idx = (numpy.array(range(a_to_finish.shape[0]))-
                          finish_idx_bases)
            finish_idx = finish_idx + result_index[atf_indexes]
            result[finish_idx,1:] = a_to_finish[:,1:]
        if len(indexes_to_keep) == 0:
            break
        #
        # Figure out which points are still available
        #
        rows_to_keep=numpy.argwhere(keep_me[a[:,0].astype(int)]).flatten()
        a = a[rows_to_keep]
        centers_per_point = centers_per_point[rows_to_keep]
        counts = new_counts
        #
        # The rule is that the area of the triangle from the center to
        # point N-1 to point N plus the area of the triangle from the center
        # to point N to point N+1 must be greater than the area of the
        # triangle from the center to point N-1 to point N+1 for a point
        # to be on the convex hull.
        # N-1 and N+1 have to be modulo "counts", so we make special arrays
        # to address those situations.
        #
        anti_indexes_to_keep = numpy.zeros((len(indexes),),int)
        anti_indexes_to_keep[indexes_to_keep] = range(len(indexes_to_keep))
        idx_base = numpy.zeros((len(indexes_to_keep),),int)
        idx_base[1:]=numpy.cumsum(counts[keep_me])[0:-1]
        idx_bases = idx_base[anti_indexes_to_keep[a[:,0]]]
        counts_per_pt = counts[a[:,0]]
        idx = numpy.array(range(a.shape[0]),int)-idx_bases
        n_minus_one = numpy.mod(idx+counts_per_pt-1,counts_per_pt)+idx_bases
        n_plus_one  = numpy.mod(idx+1,counts_per_pt)+idx_bases
        #
        # Compute the triangle areas
        #
        t_left = triangle_areas(centers_per_point,
                                a[n_minus_one,1:],
                                a[:,1:])
        t_right = triangle_areas(centers_per_point,
                                 a[:,1:],
                                 a[n_plus_one,1:])
        t_lr = triangle_areas(centers_per_point,
                              a[n_minus_one,1:],a[n_plus_one,1:])
        #
        # Keep the points where the area of the left triangle plus the
        # area of the right triangle is bigger than the area of the triangle
        # composed of the points to the left and right. This means that
        # there's a little triangle sitting on top of t_lr with our point
        # on top and convex in relation to its neighbors.
        #
        keep_me = t_left+t_right > t_lr
        #
        # If all points on a line are co-linear with the center, then the
        # whole line goes away. Special handling for this to find the points
        # most distant from the center and on the same side
        #
        consider_me = t_left+t_right == 0
        if numpy.any(consider_me):
            diff_i = a[:,1]-centers_per_point[:,0]
            diff_j = a[:,2]-centers_per_point[:,1]
            #
            # The manhattan distance is good enough
            #
            dist = numpy.abs(diff_i)+numpy.abs(diff_j)
            # The sign is different on different sides of a line including
            # the center. Multiply j by 2 to keep from colliding with i
            #
            # If both signs are zero, then the point is in the center
            #
            sign = numpy.sign(diff_i) + numpy.sign(diff_j)*2
            n_minus_one_consider = n_minus_one[consider_me]
            n_plus_one_consider = n_plus_one[consider_me]
            left_is_worse = numpy.logical_or(dist[consider_me] >
                                             dist[n_minus_one_consider],
                                             sign[consider_me] != 
                                             sign[n_minus_one_consider])
            right_is_worse = numpy.logical_or(dist[consider_me] >
                                              dist[n_plus_one_consider],
                                              sign[consider_me] !=
                                              sign[n_plus_one_consider])
            to_keep = numpy.logical_and(numpy.logical_and(left_is_worse,
                                                          right_is_worse),
                                        sign[consider_me] != 0)
            keep_me[consider_me] = to_keep 
        a = a[keep_me,:]
        centers_per_point = centers_per_point[keep_me]
    #
    # Finally, we have to shrink the results. We number each of the
    # points for a label, then only keep those whose indexes are
    # less than the count for their label.
    #
    within_label_index = numpy.array(range(result.shape[0]),int)
    counts_per_point = result_counts[r_anti_indexes_per_point]
    result_indexes_per_point = result_index[r_anti_indexes_per_point] 
    within_label_index = (within_label_index - result_indexes_per_point)
    result = result[within_label_index < counts_per_point]
    return result, result_counts

def triangle_areas(p1,p2,p3):
    """Compute an array of triangle areas given three arrays of triangle pts
    
    p1,p2,p3 - three Nx2 arrays of points
    """
    v1 = p2-p1
    v2 = p3-p1
    cross1 = v1[:,1] * v2[:,0]
    cross2 = v2[:,1] * v1[:,0]
    a = (cross1-cross2) / 2
    return a  

def draw_line(labels,pt0,pt1,value=1):
    """Draw a line between two points
    
    pt0, pt1 are in i,j format which is the reverse of x,y format
    Uses the Bresenham algorithm
    Some code transcribed from http://www.cs.unc.edu/~mcmillan/comp136/Lecture6/Lines.html
    """
    y0,x0 = pt0
    y1,x1 = pt1
    diff_y = abs(y1-y0)
    diff_x = abs(x1-x0)
    x = x0
    y = y0
    labels[y,x]=value
    step_x = (x1 > x0 and 1) or -1
    step_y = (y1 > y0 and 1) or -1
    if diff_y > diff_x:
        # Y varies fastest, do x before y
        remainder = diff_x*2 - diff_y
        while y != y1:
            if remainder >= 0:
                 x += step_x
                 remainder -= diff_y*2
            y += step_y
            remainder += diff_x*2
            labels[y,x] = value
    else:
        remainder = diff_y*2 - diff_x
        while x != x1:
            if remainder >= 0:
                 y += step_y
                 remainder -= diff_x*2
            x += step_x
            remainder += diff_y*2
            labels[y,x] = value

def fixup_scipy_ndimage_result(whatever_it_returned):
    """Convert a result from scipy.ndimage to a numpy array
    
    scipy.ndimage has the annoying habit of returning a single, bare
    value instead of an array if the indexes passed in are of length 1.
    For instance:
    scipy.ndimage.maximum(image, labels, [1]) returns a float
    but
    scipy.ndimage.maximum(image, labels, [1,2]) returns a list
    """
    if getattr(whatever_it_returned,"__getitem__",False):
        return numpy.array(whatever_it_returned)
    else:
        return numpy.array([whatever_it_returned])

def minimum_enclosing_circle(labels, indexes = None):
    """Find the location of the minimum enclosing circle and its radius
    
    labels - a labels matrix
    indexes - an array giving the label indexes to be processed
    
    returns an Nx3 array organized as i,j of the center and radius
    Algorithm from 
    http://www.personal.kent.edu/~rmuhamma/Compgeometry/MyCG/CG-Applets/Center/centercli.htm
    who calls it the Applet's Algorithm and ascribes it to Pr. Chrystal
    The original citation is Professor Chrystal, "On the problem to construct
    the minimum circle enclosing n given points in a plane", Proceedings of
    the Edinburgh Mathematical Society, vol 3, 1884
    """
    if indexes == None:
        max_label = numpy.max(labels)
        indexes = numpy.array(range(1,max_label+1))
    else:
        indexes = numpy.array(indexes)
    if indexes.shape[0] == 0:
        return numpy.zeros((0,2)),numpy.zeros((0,))

    hull, point_count = convex_hull(labels, indexes)
    centers = numpy.zeros((len(indexes),2))
    radii = numpy.zeros((len(indexes),))
    #
    # point_index is the index to the first point in "hull" for a label
    #
    point_index = numpy.zeros((indexes.shape[0],),int)
    point_index[1:] = numpy.cumsum(point_count[:-1]) 
    #
    # The algorithm is this:
    # * Choose a line S from S0 to S1 at random from the set of adjacent
    #   S0 and S1
    # * For every vertex (V) other than S, compute the angle from S0
    #   to V to S. If this angle is obtuse, the vertex V lies within the
    #   minimum enclosing circle and can be ignored.
    # * Find the minimum angle for all V.
    #   If the minimum angle is obtuse, stop and accept S as the diameter of 
    #   the circle.
    # * If some vertex V with an acute angle makes angles S0-S1-V and
    #   S1-S0-V that are also acute, then S0-S1 and V are on the edge of
    #   the minimum enclosing circle and the circumcenter of the triangle
    #   is the center of the circle
    # * Otherwise, find the largest obtuse angle among S0-S1-V and
    #   S1-S0-V, choosing V and S0 as the new S if S1 is the vertex of
    #   the obtuse angle or V and S1 as the new S if S0 is the vertex
    #   of the obtuse angle.
    #
    #
    # anti_indexes is used to transform a label # into an index in the above array
    # anti_indexes_per_point gives the label index of any vertex
    #
    anti_indexes=numpy.zeros((numpy.max(indexes)+1,),int)
    anti_indexes[indexes] = range(indexes.shape[0])
    anti_indexes_per_point = anti_indexes[hull[:,0]]
    #
    # Start out by eliminating the degenerate cases: 0, 1 and 2
    #
    centers[point_count==0,:]= numpy.NaN
    if numpy.all(point_count == 0):
        # Bail if there are no points in any hull to prevent
        # index failures below.
        return centers,radii
        
    centers[point_count==1,:]=hull[point_index[point_count==1],1:]
    radii[point_count < 2]=0
    centers[point_count==2,:]=(hull[point_index[point_count==2],1:]+
                               hull[point_index[point_count==2]+1,1:])/2
    distance = centers[point_count==2,:] - hull[point_index[point_count==2],1:]
    radii[point_count==2]=numpy.sqrt(distance[:,0]**2+distance[:,1]**2)
    #
    # Get rid of the degenerate points
    #
    keep_me = point_count > 2
    #
    # Pick S0 as the first point in each label
    # and S1 as the second.
    #
    s0_idx = point_index.copy()
    s1_idx = s0_idx+1
    #
    # number each of the points in a label with an index # which gives
    # the order in which we'll get their angles. We use this to pick out
    # points # 2 to N which are the candidate vertices to S
    # 
    within_label_indexes = (numpy.array(range(hull.shape[0]),int) -
                            point_index[anti_indexes_per_point])
    
    while(numpy.any(keep_me)):
        #############################################################
        # Label indexing for active labels
        #############################################################
        #
        # labels_to_consider contains the labels of the objects which
        # have not been completed
        #
        labels_to_consider = indexes[keep_me]
        #
        # anti_indexes_to_consider gives the index into any vector
        # shaped similarly to labels_to_consider (for instance, min_angle
        # below) for every label in labels_to_consider.
        #
        anti_indexes_to_consider =\
            numpy.zeros((numpy.max(labels_to_consider)+1,),int)
        anti_indexes_to_consider[labels_to_consider] = \
            numpy.array(range(labels_to_consider.shape[0]))
        ##############################################################
        # Vertex indexing for active vertexes other than S0 and S1
        ##############################################################
        #
        # The vertices are hull-points with indexes of 2 or more
        # keep_me_vertices is a mask of the vertices to operate on
        # during this iteration
        #
        keep_me_vertices = numpy.logical_and(keep_me[anti_indexes_per_point],
                                             within_label_indexes >= 2)
        #
        # v is the vertex coordinates for each vertex considered
        #
        v  = hull[keep_me_vertices,1:]
        #
        # v_labels is the label from the label matrix for each vertex
        #
        v_labels = hull[keep_me_vertices,0]
        #
        # v_indexes is the index into "hull" for each vertex (and similarly
        # shaped vectors such as within_label_indexes
        #
        v_indexes=numpy.argwhere(keep_me_vertices).flatten()
        #
        # anti_indexes_per_vertex gives the index into "indexes" and
        # any similarly shaped array of per-label values
        # (for instance s0_idx) for each vertex being considered
        #
        anti_indexes_per_vertex = anti_indexes_per_point[keep_me_vertices]
        #
        # anti_indexes_to_consider_per_vertex gives the index into any
        # vector shaped similarly to labels_to_consider for each
        # vertex being analyzed
        #
        anti_indexes_to_consider_per_vertex = anti_indexes_to_consider[v_labels]
        #
        # Get S0 and S1 per vertex
        #
        s0 = hull[s0_idx[keep_me],1:]
        s1 = hull[s1_idx[keep_me],1:]
        s0 = s0[anti_indexes_to_consider_per_vertex]
        s1 = s1[anti_indexes_to_consider_per_vertex]
        #
        # Compute the angle S0-S1-V
        #
        # the first vector of the angles is between S0 and S1
        #
        s01 = (s0 - s1).astype(float)
        #
        # compute V-S1 and V-S0 at each of the vertices to be considered
        #
        vs0 = (v - s0).astype(float)
        vs1 = (v - s1).astype(float) 
        #
        #` Take the dot product of s01 and vs1 divided by the length of s01 *
        # the length of vs1. This gives the cosine of the angle between.
        #
        dot_vs1s0 = (numpy.sum(s01*vs1,1) /
                     numpy.sqrt(numpy.sum(s01**2,1)*numpy.sum(vs1**2,1)))
        angle_vs1s0 = numpy.abs(numpy.arccos(dot_vs1s0))
        s10 = -s01
        dot_vs0s1 = (numpy.sum(s10*vs0,1) /
                     numpy.sqrt(numpy.sum(s01**2,1)*numpy.sum(vs0**2,1)))
        angle_vs0s1 = numpy.abs(numpy.arccos(dot_vs0s1))
        #
        # S0-V-S1 is pi - the other two
        #
        angle_s0vs1 = numpy.pi - angle_vs1s0 - angle_vs0s1
        assert numpy.all(angle_s0vs1 >= 0)
        #
        # Now we find the minimum angle per label
        #
        min_angle = scipy.ndimage.minimum(angle_s0vs1,v_labels,
                                          labels_to_consider)
        min_angle = fixup_scipy_ndimage_result(min_angle)
        min_angle_per_vertex = min_angle[anti_indexes_to_consider_per_vertex]
        #
        # Calculate the index into V of the minimum angle per label.
        # Use "indexes" instead of labels_to_consider so we get something
        # with the same shape as keep_me
        #
        min_position = scipy.ndimage.minimum_position(angle_s0vs1,v_labels,
                                                      indexes)
        min_position = fixup_scipy_ndimage_result(min_position)
        min_position = min_position.flatten()
        #
        # Case 1: minimum angle is obtuse or right. Accept S as the diameter.
        # Case 1a: there are no vertices. Accept S as the diameter.
        #
        vertex_counts = scipy.ndimage.sum(keep_me_vertices,
                                          hull[:,0],
                                          labels_to_consider)
        vertex_counts = fixup_scipy_ndimage_result(vertex_counts)
        case_1 = numpy.logical_or(min_angle >= numpy.pi / 2,
                                  vertex_counts == 0)
                                   
        if numpy.any(case_1):
            # convert from a boolean over indexes_to_consider to a boolean
            # over indexes
            finish_me = numpy.zeros((indexes.shape[0],),bool)
            finish_me[anti_indexes[labels_to_consider[case_1]]] = True
            s0_finish_me = hull[s0_idx[finish_me],1:].astype(float)
            s1_finish_me = hull[s1_idx[finish_me],1:].astype(float)
            centers[finish_me] = (s0_finish_me + s1_finish_me)/2
            radii[finish_me] = numpy.sqrt(numpy.sum((s0_finish_me - 
                                                     s1_finish_me)**2,1))/2
            keep_me[finish_me] = False
        #
        # Case 2: all angles for the minimum angle vertex are acute 
        #         or right.
        #         Pick S0, S1 and the vertex with the
        #         smallest angle as 3 points on the circle. If you look at the
        #         geometry, the diameter is the length of S0-S1 divided by
        #         the cosine of 1/2 of the angle. The center of the circle
        #         is at the circumcenter of the triangle formed by S0, S1 and
        #         V.
        case_2 = keep_me.copy()
        case_2[angle_vs1s0[min_position] > numpy.pi/2] = False
        case_2[angle_vs0s1[min_position] > numpy.pi/2] = False
        case_2[angle_s0vs1[min_position] > numpy.pi/2] = False
        
        if numpy.any(case_2):
            #
            # Wikipedia (http://en.wikipedia.org/wiki/Circumcircle#Cartesian_coordinates)
            # gives the following:
            # D = 2(S0y Vx + S1y S0x - S1y Vx - S0y S1x - S0x Vy + S1x Vy)
            # D = 2(S0x (S1y-Vy) + S1x(Vy-S0y) + Vx(S0y-S1y)
            # x = ((S0x**2+S0y**2)(S1y-Vy)+(S1x**2+S1y**2)(Vy-S0y)+(Vx**2+Vy**2)(S0y-S1y)) / D
            # y = ((S0x**2+S0y**2)(Vx-S1x)+(S1x**2+S1y**2)(S0y-Vy)+(Vx**2+Vy**2)(S1y-S0y)) / D
            #
            ss0 = hull[s0_idx[case_2],1:].astype(float)
            ss1 = hull[s1_idx[case_2],1:].astype(float)
            vv  = v[min_position[case_2]].astype(float)
            Y = 0
            X = 1 
            D = 2*(ss0[:,X] * (ss1[:,Y] - vv[:,Y]) +
                   ss1[:,X] * (vv[:,Y]  - ss0[:,Y]) +
                   vv[:,X]  * (ss0[:,Y] - ss1[:,Y]))
            x = (numpy.sum(ss0**2,1)*(ss1[:,Y] - vv[:,Y]) +
                 numpy.sum(ss1**2,1)*(vv[:,Y]  - ss0[:,Y]) +
                 numpy.sum(vv**2,1) *(ss0[:,Y] - ss1[:,Y])) / D
            y = (numpy.sum(ss0**2,1)*(vv[:,X]  - ss1[:,X]) +
                 numpy.sum(ss1**2,1)*(ss0[:,X] - vv[:,X]) +
                 numpy.sum(vv**2,1) *(ss1[:,X] - ss0[:,X])) / D
            centers[case_2,X] = x
            centers[case_2,Y] = y
            distances = ss0-centers[case_2]
            radii[case_2] = numpy.sqrt(numpy.sum(distances**2,1))
            keep_me[case_2] = False
        #
        # Finally, for anybody who's left, for each of S0-S1-V and
        # S1-S0-V, for V, the vertex with the minimum angle,
        # find the largest obtuse angle. The vertex of this
        # angle (S0 or S1) is inside the enclosing circle, so take V
        # and either S1 or S0 as the new S.
        #
        # This involves a relabeling of within_label_indexes. We replace
        # either S0 or S1 with V and assign V either 0 or 1
        #
        if numpy.any(keep_me):
            labels_to_consider = indexes[keep_me]
            indexes_to_consider = anti_indexes[labels_to_consider]
            #
            # Index into within_label_indexes for each V with the
            # smallest angle
            #
            v_obtuse_indexes = v_indexes[min_position[keep_me]]
            angle_vs0s1_to_consider = angle_vs0s1[min_position[keep_me]]
            angle_vs1s0_to_consider = angle_vs1s0[min_position[keep_me]]
            #
            # Do the cases where S0 is larger
            #
            s0_is_obtuse = angle_vs0s1_to_consider > numpy.pi/2
            if numpy.any(s0_is_obtuse):
                #
                # The index of the obtuse S0
                #
                v_obtuse_s0_indexes = v_obtuse_indexes[s0_is_obtuse]
                obtuse_s0_idx = s0_idx[indexes_to_consider[s0_is_obtuse]]
                #
                # S0 gets the within_label_index of the vertex
                #
                within_label_indexes[obtuse_s0_idx] = \
                    within_label_indexes[v_obtuse_s0_indexes]
                #
                # Assign V as the new S0
                #
                s0_idx[indexes_to_consider[s0_is_obtuse]] = v_obtuse_s0_indexes
                within_label_indexes[v_obtuse_s0_indexes] = 0
            #
            # Do the cases where S1 is larger
            #
            s1_is_obtuse = numpy.logical_not(s0_is_obtuse)
            if numpy.any(s1_is_obtuse):
                #
                # The index of the obtuse S1
                #
                v_obtuse_s1_indexes = v_obtuse_indexes[s1_is_obtuse]
                obtuse_s1_idx = s1_idx[indexes_to_consider[s1_is_obtuse]]
                #
                # S1 gets V's within_label_index and goes onto the list
                # of considered vertices.
                #
                within_label_indexes[obtuse_s1_idx] = \
                    within_label_indexes[v_obtuse_s1_indexes]
                #
                # Assign V as the new S1
                #
                s1_idx[indexes_to_consider[s1_is_obtuse]] = v_obtuse_s1_indexes
                within_label_indexes[v_obtuse_s1_indexes] = 1
    return centers, radii
