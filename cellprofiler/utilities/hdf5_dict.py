''' hdf5_dict -- HDF5-backed dictionary for Measurements.

This module implements the HDF5Dict class, which provides a dict-like
interface for measurements, backed by an HDF5 file.
'''

import threading
import h5py

# h5py is nice, but not being able to make zero-length selections is a pain.
orig_hdf5_getitem = h5py.Dataset.__getitem__
def new_getitem(self, args):
    if isinstance(args, slice) and \
            args.start is not None and args.start == args.stop:
        return np.array([], self.dtype)
    return orig_hdf5_getitem(self, args)
setattr(h5py.Dataset, orig_hdf5_getitem.__name__, new_getitem)

orig_hdf5_setitem = h5py.Dataset.__setitem__
def new_setitem(self, args, val):
    if isinstance(args, slice) and \
            args.start is not None and args.start == args.stop:
        return np.array([], self.dtype)[0:0]
    return orig_hdf5_setitem(self, args, val)
setattr(h5py.Dataset, orig_hdf5_setitem.__name__, new_setitem)


class HDF5Dict():
    ''' The HDF5Dict can be used to store measurements at several
    hierarchical levels:

    measurements = HDFDict(hdf5_filename)
    
    # Experiment-level features
    measurements['Experiment', 'feature1'] = 'a'
    measurements['Experiment', 'feature2'] = 1
    
    # Image-level features
    measurements['Image', 'imfeature1', 1] = 'foo'
    measurements['Image', 'imfeature2', 1] = 5

    # Object-level features
    measurements['Object1', 'objfeature1', 1, :] = [1, 2, 3]
    measurements['Object1', 'objfeature2', 1, :] = [4.0, 5.0, 6.0]
    
    The first two axes are strings, all other are indices.
    Measurements can be fetched using indices, including slices in any
    but the first (object name) index, with the exptected results.  If
    the second axis (the feature column) is sliced, a structured array
    will be returned.

    Integers, floats, and strings can be stored in the measurments.

    Data can be removed with the del operator.

    Depending on the number of levels used to store measurements,
    several implicit index features will be included.  For Image-level
    features, an integer 'ImageNumber' with 0-based indexing will be
    included.  For Object and deeper levels, there will also be
    'ObjectNumber', 'SubObjectNumber', 'SubSubObjectNumber',
    etc. depending on the level.  When assigning to slices, these will
    be autogenerated according to the data length.

    It is an error to overwrite existing data, unless the 'overwrite'
    property is set on the measurements object.

    If the 'not_missing' flag is set, it is an error to add a new
    object or feature that does not exist.

    It is also an error to write different amounts of data for
    different features on the same object.

    # Assign 3 object measurements to Object1.objectfeature1:
    measurements['Object1', 'objfeature1', 1, :] = [1, 2, 3]
    # Error!  attempting to assign 4 measurements to the same object.
    measurements['Object1', 'objfeature2', 1, :] = [1, 2, 3, 4]
    
    '''

    # XXX - document how data is stored in hdf5 (basically, /Measurements/Object/Feature)

    def __init__(self, hdf5_filename, top_level_group_name="Measurements"):
        self.hdf_filename = hdf_filename
        assert not os.path.exists(hdf_filename)  # currently, don't allow overwrite
        self.hdf_file = h5py.File(self.hdf_filename, 'w')
        self.top_level_group_name = top_level_group_name
        self.group = self.hdf_file.create_group(top_level_group_name)

        self.lock = threading.RLock()  # h5py is thread safe, but does not support simultaneous read/write
        
