#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Fri Apr 13 13:33:23 2012 by generateDS.py version 2.7b.
#

import sys
import getopt
import re as re_

import xml.etree.ElementTree as etree_

def parsexml_(*args, **kwargs):
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    assert len(attr_parts) == 1

    return attrs.get(attr_name)

class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class RequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CreateContext=None, DestroyContext=None, GetModules=None, RunModule=None):
        self.CreateContext = CreateContext
        self.DestroyContext = DestroyContext
        self.GetModules = GetModules
        self.RunModule = RunModule
    def factory(*args_, **kwargs_):
        if RequestType.subclass:
            return RequestType.subclass(*args_, **kwargs_)
        else:
            return RequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CreateContext(self): return self.CreateContext
    def set_CreateContext(self, CreateContext): self.CreateContext = CreateContext
    def get_DestroyContext(self): return self.DestroyContext
    def set_DestroyContext(self, DestroyContext): self.DestroyContext = DestroyContext
    def get_GetModules(self): return self.GetModules
    def set_GetModules(self, GetModules): self.GetModules = GetModules
    def get_RunModule(self): return self.RunModule
    def set_RunModule(self, RunModule): self.RunModule = RunModule
    def export(self, outfile, level, namespace_='ijr:', name_='RequestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='RequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='RequestType', fromsubclass_=False):
        if self.CreateContext is not None:
            self.CreateContext.export(outfile, level, namespace_, name_='CreateContext', )
        if self.DestroyContext is not None:
            self.DestroyContext.export(outfile, level, namespace_, name_='DestroyContext', )
        if self.GetModules is not None:
            self.GetModules.export(outfile, level, namespace_, name_='GetModules', )
        if self.RunModule is not None:
            self.RunModule.export(outfile, level, namespace_, name_='RunModule', )
    def hasContent_(self):
        if (
            self.CreateContext is not None or
            self.DestroyContext is not None or
            self.GetModules is not None or
            self.RunModule is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CreateContext is not None:
            showIndent(outfile, level)
            outfile.write('CreateContext=model_.CreateContextRequestType(\n')
            self.CreateContext.exportLiteral(outfile, level, name_='CreateContext')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DestroyContext is not None:
            showIndent(outfile, level)
            outfile.write('DestroyContext=model_.DestroyContextRequestType(\n')
            self.DestroyContext.exportLiteral(outfile, level, name_='DestroyContext')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GetModules is not None:
            showIndent(outfile, level)
            outfile.write('GetModules=model_.GetModulesRequestType(\n')
            self.GetModules.exportLiteral(outfile, level, name_='GetModules')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RunModule is not None:
            showIndent(outfile, level)
            outfile.write('RunModule=model_.RunModuleRequestType(\n')
            self.RunModule.exportLiteral(outfile, level, name_='RunModule')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CreateContext':
            obj_ = CreateContextRequestType.factory()
            obj_.build(child_)
            self.set_CreateContext(obj_)
        elif nodeName_ == 'DestroyContext':
            obj_ = DestroyContextRequestType.factory()
            obj_.build(child_)
            self.set_DestroyContext(obj_)
        elif nodeName_ == 'GetModules':
            obj_ = GetModulesRequestType.factory()
            obj_.build(child_)
            self.set_GetModules(obj_)
        elif nodeName_ == 'RunModule':
            obj_ = RunModuleRequestType.factory()
            obj_.build(child_)
            self.set_RunModule(obj_)
# end class RequestType


class ContextType(GeneratedsSuper):
    """The context-id identifies the ImageJ context"""
    subclass = None
    superclass = None
    def __init__(self, ContextID=None):
        self.ContextID = _cast(None, ContextID)
        pass
    def factory(*args_, **kwargs_):
        if ContextType.subclass:
            return ContextType.subclass(*args_, **kwargs_)
        else:
            return ContextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContextID(self): return self.ContextID
    def set_ContextID(self, ContextID): self.ContextID = ContextID
    def export(self, outfile, level, namespace_='ijr:', name_='ContextType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContextType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ContextType'):
        if self.ContextID is not None and 'ContextID' not in already_processed:
            already_processed.append('ContextID')
            outfile.write(' ContextID=%s' % (quote_attrib(self.ContextID), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ContextType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContextType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ContextID is not None and 'ContextID' not in already_processed:
            already_processed.append('ContextID')
            showIndent(outfile, level)
            outfile.write('ContextID = "%s",\n' % (self.ContextID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ContextID', node)
        if value is not None and 'ContextID' not in already_processed:
            already_processed.append('ContextID')
            self.ContextID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContextType


class CreateContextRequestType(GeneratedsSuper):
    """Create an ImageJ contextIf present, the context remains available
    until this time. Default is forever. Context can be destroyed by
    a destroy-context request"""
    subclass = None
    superclass = None
    def __init__(self, Lifespan=None):
        self.Lifespan = _cast(None, Lifespan)
        pass
    def factory(*args_, **kwargs_):
        if CreateContextRequestType.subclass:
            return CreateContextRequestType.subclass(*args_, **kwargs_)
        else:
            return CreateContextRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Lifespan(self): return self.Lifespan
    def set_Lifespan(self, Lifespan): self.Lifespan = Lifespan
    def export(self, outfile, level, namespace_='ijr:', name_='CreateContextRequestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreateContextRequestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='CreateContextRequestType'):
        if self.Lifespan is not None and 'Lifespan' not in already_processed:
            already_processed.append('Lifespan')
            outfile.write(' Lifespan=%s' % (self.gds_format_string(quote_attrib(self.Lifespan).encode(ExternalEncoding), input_name='Lifespan'), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='CreateContextRequestType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CreateContextRequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Lifespan is not None and 'Lifespan' not in already_processed:
            already_processed.append('Lifespan')
            showIndent(outfile, level)
            outfile.write('Lifespan = "%s",\n' % (self.Lifespan,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Lifespan', node)
        if value is not None and 'Lifespan' not in already_processed:
            already_processed.append('Lifespan')
            self.Lifespan = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreateContextRequestType


class CreateContextResponseType(GeneratedsSuper):
    """The response from a create context request."""
    subclass = None
    superclass = None
    def __init__(self, ContextID=None):
        self.ContextID = ContextID
    def factory(*args_, **kwargs_):
        if CreateContextResponseType.subclass:
            return CreateContextResponseType.subclass(*args_, **kwargs_)
        else:
            return CreateContextResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContextID(self): return self.ContextID
    def set_ContextID(self, ContextID): self.ContextID = ContextID
    def export(self, outfile, level, namespace_='ijr:', name_='CreateContextResponseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreateContextResponseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='CreateContextResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='CreateContextResponseType', fromsubclass_=False):
        if self.ContextID is not None:
            self.ContextID.export(outfile, level, namespace_, name_='ContextID', )
    def hasContent_(self):
        if (
            self.ContextID is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CreateContextResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ContextID is not None:
            showIndent(outfile, level)
            outfile.write('ContextID=model_.ContextType(\n')
            self.ContextID.exportLiteral(outfile, level, name_='ContextID')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContextID':
            obj_ = ContextType.factory()
            obj_.build(child_)
            self.set_ContextID(obj_)
# end class CreateContextResponseType


class ResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CreateContextResponse=None, GetModulesResponse=None, Exception=None, RunModuleResponse=None):
        self.CreateContextResponse = CreateContextResponse
        self.GetModulesResponse = GetModulesResponse
        self.Exception = Exception
        self.RunModuleResponse = RunModuleResponse
    def factory(*args_, **kwargs_):
        if ResponseType.subclass:
            return ResponseType.subclass(*args_, **kwargs_)
        else:
            return ResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CreateContextResponse(self): return self.CreateContextResponse
    def set_CreateContextResponse(self, CreateContextResponse): self.CreateContextResponse = CreateContextResponse
    def get_GetModulesResponse(self): return self.GetModulesResponse
    def set_GetModulesResponse(self, GetModulesResponse): self.GetModulesResponse = GetModulesResponse
    def get_Exception(self): return self.Exception
    def set_Exception(self, Exception): self.Exception = Exception
    def get_RunModuleResponse(self): return self.RunModuleResponse
    def set_RunModuleResponse(self, RunModuleResponse): self.RunModuleResponse = RunModuleResponse
    def export(self, outfile, level, namespace_='ijr:', name_='ResponseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ResponseType', fromsubclass_=False):
        if self.CreateContextResponse is not None:
            self.CreateContextResponse.export(outfile, level, namespace_, name_='CreateContextResponse')
        if self.GetModulesResponse is not None:
            self.GetModulesResponse.export(outfile, level, namespace_, name_='GetModulesResponse')
        if self.Exception is not None:
            self.Exception.export(outfile, level, namespace_, name_='Exception')
        if self.RunModuleResponse is not None:
            self.RunModuleResponse.export(outfile, level, namespace_, name_='RunModuleResponse')
    def hasContent_(self):
        if (
            self.CreateContextResponse is not None or
            self.GetModulesResponse is not None or
            self.Exception is not None or
            self.RunModuleResponse is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CreateContextResponse is not None:
            showIndent(outfile, level)
            outfile.write('CreateContextResponse=model_.CreateContextResponseType(\n')
            self.CreateContextResponse.exportLiteral(outfile, level, name_='CreateContextResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GetModulesResponse is not None:
            showIndent(outfile, level)
            outfile.write('GetModulesResponse=model_.GetModulesResponseType(\n')
            self.GetModulesResponse.exportLiteral(outfile, level, name_='GetModulesResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Exception is not None:
            showIndent(outfile, level)
            outfile.write('Exception=model_.ExceptionResponseType(\n')
            self.Exception.exportLiteral(outfile, level, name_='Exception')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RunModuleResponse is not None:
            showIndent(outfile, level)
            outfile.write('RunModuleResponse=model_.RunModuleResponseType(\n')
            self.RunModuleResponse.exportLiteral(outfile, level, name_='RunModuleResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CreateContextResponse':
            obj_ = CreateContextResponseType.factory()
            obj_.build(child_)
            self.set_CreateContextResponse(obj_)
        elif nodeName_ == 'GetModulesResponse':
            obj_ = GetModulesResponseType.factory()
            obj_.build(child_)
            self.set_GetModulesResponse(obj_)
        elif nodeName_ == 'Exception':
            obj_ = ExceptionResponseType.factory()
            obj_.build(child_)
            self.set_Exception(obj_)
        elif nodeName_ == 'RunModuleResponse':
            obj_ = RunModuleResponseType.factory()
            obj_.build(child_)
            self.set_RunModuleResponse(obj_)
# end class ResponseType


class ExceptionResponseType(GeneratedsSuper):
    """An exception thrown during the course of execution."""
    subclass = None
    superclass = None
    def __init__(self, Message=None, StackTrace=None):
        self.Message = Message
        self.StackTrace = StackTrace
    def factory(*args_, **kwargs_):
        if ExceptionResponseType.subclass:
            return ExceptionResponseType.subclass(*args_, **kwargs_)
        else:
            return ExceptionResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Message(self): return self.Message
    def set_Message(self, Message): self.Message = Message
    def get_StackTrace(self): return self.StackTrace
    def set_StackTrace(self, StackTrace): self.StackTrace = StackTrace
    def export(self, outfile, level, namespace_='ijr:', name_='ExceptionResponseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExceptionResponseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ExceptionResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ExceptionResponseType', fromsubclass_=False):
        if self.Message is not None:
            showIndent(outfile, level)
            outfile.write('<%sMessage>%s</%sMessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.Message).encode(ExternalEncoding), input_name='Message'), namespace_))
        if self.StackTrace is not None:
            showIndent(outfile, level)
            outfile.write('<%sStackTrace>%s</%sStackTrace>\n' % (namespace_, self.gds_format_string(quote_xml(self.StackTrace).encode(ExternalEncoding), input_name='StackTrace'), namespace_))
    def hasContent_(self):
        if (
            self.Message is not None or
            self.StackTrace is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExceptionResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Message is not None:
            showIndent(outfile, level)
            outfile.write('Message=%s,\n' % quote_python(self.Message).encode(ExternalEncoding))
        if self.StackTrace is not None:
            showIndent(outfile, level)
            outfile.write('StackTrace=%s,\n' % quote_python(self.StackTrace).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Message':
            Message_ = child_.text
            Message_ = self.gds_validate_string(Message_, node, 'Message')
            self.Message = Message_
        elif nodeName_ == 'StackTrace':
            StackTrace_ = child_.text
            StackTrace_ = self.gds_validate_string(StackTrace_, node, 'StackTrace')
            self.StackTrace = StackTrace_
# end class ExceptionResponseType


class Type(GeneratedsSuper):
    """This is the Java class for the item's datatype."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Type.subclass:
            return Type.subclass(*args_, **kwargs_)
        else:
            return Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Type


class IOType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IOType.subclass:
            return IOType.subclass(*args_, **kwargs_)
        else:
            return IOType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='IOType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IOType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='IOType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='IOType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IOType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IOType


class Visibility(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Visibility.subclass:
            return Visibility.subclass(*args_, **kwargs_)
        else:
            return Visibility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='Visibility', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Visibility')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='Visibility'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='Visibility', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Visibility'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Visibility


class WidgetStyle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if WidgetStyle.subclass:
            return WidgetStyle.subclass(*args_, **kwargs_)
        else:
            return WidgetStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='WidgetStyle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WidgetStyle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='WidgetStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='WidgetStyle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WidgetStyle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WidgetStyle


class BasicDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Label=None, Description=None, extensiontype_=None):
        self.Name = Name
        self.Label = Label
        self.Description = Description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if BasicDetailsType.subclass:
            return BasicDetailsType.subclass(*args_, **kwargs_)
        else:
            return BasicDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='ijr:', name_='BasicDetailsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicDetailsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='BasicDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='BasicDetailsType', fromsubclass_=False):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('<%sLabel>%s</%sLabel>\n' % (namespace_, self.gds_format_string(quote_xml(self.Label).encode(ExternalEncoding), input_name='Label'), namespace_))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Label is not None or
            self.Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BasicDetailsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=%s,\n' % quote_python(self.Label).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Label':
            Label_ = child_.text
            Label_ = self.gds_validate_string(Label_, node, 'Label')
            self.Label = Label_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class BasicDetailsType


class MenuEntryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Weight=None, Mnemonic=None, Accelerator=None, IconPath=None):
        self.Name = Name
        self.Weight = Weight
        self.Mnemonic = Mnemonic
        self.Accelerator = Accelerator
        self.IconPath = IconPath
    def factory(*args_, **kwargs_):
        if MenuEntryType.subclass:
            return MenuEntryType.subclass(*args_, **kwargs_)
        else:
            return MenuEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_Mnemonic(self): return self.Mnemonic
    def set_Mnemonic(self, Mnemonic): self.Mnemonic = Mnemonic
    def get_Accelerator(self): return self.Accelerator
    def set_Accelerator(self, Accelerator): self.Accelerator = Accelerator
    def get_IconPath(self): return self.IconPath
    def set_IconPath(self, IconPath): self.IconPath = IconPath
    def export(self, outfile, level, namespace_='ijr:', name_='MenuEntryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MenuEntryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='MenuEntryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='MenuEntryType', fromsubclass_=False):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
        if self.Weight is not None:
            showIndent(outfile, level)
            outfile.write('<%sWeight>%s</%sWeight>\n' % (namespace_, self.gds_format_double(self.Weight, input_name='Weight'), namespace_))
        if self.Mnemonic is not None:
            showIndent(outfile, level)
            outfile.write('<%sMnemonic>%s</%sMnemonic>\n' % (namespace_, self.gds_format_string(quote_xml(self.Mnemonic).encode(ExternalEncoding), input_name='Mnemonic'), namespace_))
        if self.Accelerator is not None:
            self.Accelerator.export(outfile, level, namespace_, name_='Accelerator')
        if self.IconPath is not None:
            showIndent(outfile, level)
            outfile.write('<%sIconPath>%s</%sIconPath>\n' % (namespace_, self.gds_format_string(quote_xml(self.IconPath).encode(ExternalEncoding), input_name='IconPath'), namespace_))
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Weight is not None or
            self.Mnemonic is not None or
            self.Accelerator is not None or
            self.IconPath is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MenuEntryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Weight is not None:
            showIndent(outfile, level)
            outfile.write('Weight=%e,\n' % self.Weight)
        if self.Mnemonic is not None:
            showIndent(outfile, level)
            outfile.write('Mnemonic=%s,\n' % quote_python(self.Mnemonic).encode(ExternalEncoding))
        if self.Accelerator is not None:
            showIndent(outfile, level)
            outfile.write('Accelerator=model_.AcceleratorType(\n')
            self.Accelerator.exportLiteral(outfile, level, name_='Accelerator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IconPath is not None:
            showIndent(outfile, level)
            outfile.write('IconPath=%s,\n' % quote_python(self.IconPath).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
        elif nodeName_ == 'Mnemonic':
            Mnemonic_ = child_.text
            Mnemonic_ = self.gds_validate_string(Mnemonic_, node, 'Mnemonic')
            self.Mnemonic = Mnemonic_
        elif nodeName_ == 'Accelerator':
            obj_ = AcceleratorType.factory()
            obj_.build(child_)
            self.set_Accelerator(obj_)
        elif nodeName_ == 'IconPath':
            IconPath_ = child_.text
            IconPath_ = self.gds_validate_string(IconPath_, node, 'IconPath')
            self.IconPath = IconPath_
# end class MenuEntryType


class Mnemonic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Mnemonic.subclass:
            return Mnemonic.subclass(*args_, **kwargs_)
        else:
            return Mnemonic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='Mnemonic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Mnemonic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='Mnemonic'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='Mnemonic', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Mnemonic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Mnemonic


class AcceleratorType(GeneratedsSuper):
    """True if alt must be pressed to activate. Ctrl must be pressed to
    activate. The key to press. See imagej.ext.KeyCode for possible
    values."""
    subclass = None
    superclass = None
    def __init__(self, ShiftDown=None, AltDown=None, CtrlDown=None, KeyCode=None):
        self.ShiftDown = _cast(bool, ShiftDown)
        self.AltDown = _cast(bool, AltDown)
        self.CtrlDown = _cast(bool, CtrlDown)
        self.KeyCode = _cast(int, KeyCode)
        pass
    def factory(*args_, **kwargs_):
        if AcceleratorType.subclass:
            return AcceleratorType.subclass(*args_, **kwargs_)
        else:
            return AcceleratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShiftDown(self): return self.ShiftDown
    def set_ShiftDown(self, ShiftDown): self.ShiftDown = ShiftDown
    def get_AltDown(self): return self.AltDown
    def set_AltDown(self, AltDown): self.AltDown = AltDown
    def get_CtrlDown(self): return self.CtrlDown
    def set_CtrlDown(self, CtrlDown): self.CtrlDown = CtrlDown
    def get_KeyCode(self): return self.KeyCode
    def set_KeyCode(self, KeyCode): self.KeyCode = KeyCode
    def export(self, outfile, level, namespace_='ijr:', name_='AcceleratorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcceleratorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='AcceleratorType'):
        if self.ShiftDown is not None and 'ShiftDown' not in already_processed:
            already_processed.append('ShiftDown')
            outfile.write(' ShiftDown="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.ShiftDown)), input_name='ShiftDown'))
        if self.AltDown is not None and 'AltDown' not in already_processed:
            already_processed.append('AltDown')
            outfile.write(' AltDown="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.AltDown)), input_name='AltDown'))
        if self.CtrlDown is not None and 'CtrlDown' not in already_processed:
            already_processed.append('CtrlDown')
            outfile.write(' CtrlDown="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.CtrlDown)), input_name='CtrlDown'))
        if self.KeyCode is not None and 'KeyCode' not in already_processed:
            already_processed.append('KeyCode')
            outfile.write(' KeyCode="%s"' % self.gds_format_integer(self.KeyCode, input_name='KeyCode'))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='AcceleratorType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AcceleratorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ShiftDown is not None and 'ShiftDown' not in already_processed:
            already_processed.append('ShiftDown')
            showIndent(outfile, level)
            outfile.write('ShiftDown = %s,\n' % (self.ShiftDown,))
        if self.AltDown is not None and 'AltDown' not in already_processed:
            already_processed.append('AltDown')
            showIndent(outfile, level)
            outfile.write('AltDown = %s,\n' % (self.AltDown,))
        if self.CtrlDown is not None and 'CtrlDown' not in already_processed:
            already_processed.append('CtrlDown')
            showIndent(outfile, level)
            outfile.write('CtrlDown = %s,\n' % (self.CtrlDown,))
        if self.KeyCode is not None and 'KeyCode' not in already_processed:
            already_processed.append('KeyCode')
            showIndent(outfile, level)
            outfile.write('KeyCode = %d,\n' % (self.KeyCode,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ShiftDown', node)
        if value is not None and 'ShiftDown' not in already_processed:
            already_processed.append('ShiftDown')
            if value in ('true', '1'):
                self.ShiftDown = True
            elif value in ('false', '0'):
                self.ShiftDown = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('AltDown', node)
        if value is not None and 'AltDown' not in already_processed:
            already_processed.append('AltDown')
            if value in ('true', '1'):
                self.AltDown = True
            elif value in ('false', '0'):
                self.AltDown = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CtrlDown', node)
        if value is not None and 'CtrlDown' not in already_processed:
            already_processed.append('CtrlDown')
            if value in ('true', '1'):
                self.CtrlDown = True
            elif value in ('false', '0'):
                self.CtrlDown = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('KeyCode', node)
        if value is not None and 'KeyCode' not in already_processed:
            already_processed.append('KeyCode')
            try:
                self.KeyCode = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AcceleratorType


class GetModulesResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Module=None):
        if Module is None:
            self.Module = []
        else:
            self.Module = Module
    def factory(*args_, **kwargs_):
        if GetModulesResponseType.subclass:
            return GetModulesResponseType.subclass(*args_, **kwargs_)
        else:
            return GetModulesResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Module(self): return self.Module
    def set_Module(self, Module): self.Module = Module
    def add_Module(self, value): self.Module.append(value)
    def insert_Module(self, index, value): self.Module[index] = value
    def export(self, outfile, level, namespace_='ijr:', name_='GetModulesResponseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GetModulesResponseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='GetModulesResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='GetModulesResponseType', fromsubclass_=False):
        for Module_ in self.Module:
            Module_.export(outfile, level, namespace_, name_='Module')
    def hasContent_(self):
        if (
            self.Module
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GetModulesResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Module=[\n')
        level += 1
        for Module_ in self.Module:
            showIndent(outfile, level)
            outfile.write('model_.ModuleInfoType(\n')
            Module_.exportLiteral(outfile, level, name_='ModuleInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Module':
            obj_ = ModuleInfoType.factory()
            obj_.build(child_)
            self.Module.append(obj_)
# end class GetModulesResponseType


class ContextRequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ContextID=None, extensiontype_=None):
        self.ContextID = _cast(None, ContextID)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ContextRequestType.subclass:
            return ContextRequestType.subclass(*args_, **kwargs_)
        else:
            return ContextRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContextID(self): return self.ContextID
    def set_ContextID(self, ContextID): self.ContextID = ContextID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='ijr:', name_='ContextRequestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContextRequestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ContextRequestType'):
        if self.ContextID is not None and 'ContextID' not in already_processed:
            already_processed.append('ContextID')
            outfile.write(' ContextID=%s' % (quote_attrib(self.ContextID), ))

    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ContextRequestType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContextRequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ContextID is not None and 'ContextID' not in already_processed:
            already_processed.append('ContextID')
            showIndent(outfile, level)
            outfile.write('ContextID = "%s",\n' % (self.ContextID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ContextID', node)
        if value is not None and 'ContextID' not in already_processed:
            already_processed.append('ContextID')
            self.ContextID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContextRequestType


class ParameterValueType(GeneratedsSuper):
    """The parameter's name - for plugins, this is the field's Java name."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, ImageValue=None, StringValue=None, NumberValue=None, BooleanValue=None, ColorValue=None, extensiontype_=None):
        self.Name = _cast(None, Name)
        self.ImageValue = ImageValue
        self.StringValue = StringValue
        self.NumberValue = NumberValue
        self.BooleanValue = BooleanValue
        self.ColorValue = ColorValue
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ParameterValueType.subclass:
            return ParameterValueType.subclass(*args_, **kwargs_)
        else:
            return ParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ImageValue(self): return self.ImageValue
    def set_ImageValue(self, ImageValue): self.ImageValue = ImageValue
    def get_StringValue(self): return self.StringValue
    def set_StringValue(self, StringValue): self.StringValue = StringValue
    def get_NumberValue(self): return self.NumberValue
    def set_NumberValue(self, NumberValue): self.NumberValue = NumberValue
    def get_BooleanValue(self): return self.BooleanValue
    def set_BooleanValue(self, BooleanValue): self.BooleanValue = BooleanValue
    def get_ColorValue(self): return self.ColorValue
    def set_ColorValue(self, ColorValue): self.ColorValue = ColorValue
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='ijr:', name_='ParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ParameterValueType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ParameterValueType', fromsubclass_=False):
        if self.ImageValue is not None:
            self.ImageValue.export(outfile, level, namespace_, name_='ImageValue')
        if self.StringValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sStringValue>%s</%sStringValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.StringValue).encode(ExternalEncoding), input_name='StringValue'), namespace_))
        if self.NumberValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumberValue>%s</%sNumberValue>\n' % (namespace_, self.gds_format_float(self.NumberValue, input_name='NumberValue'), namespace_))
        if self.BooleanValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sBooleanValue>%s</%sBooleanValue>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.BooleanValue)), input_name='BooleanValue'), namespace_))
        if self.ColorValue is not None:
            self.ColorValue.export(outfile, level, namespace_, name_='ColorValue')
    def hasContent_(self):
        if (
            self.ImageValue is not None or
            self.StringValue is not None or
            self.NumberValue is not None or
            self.BooleanValue is not None or
            self.ColorValue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ImageValue is not None:
            showIndent(outfile, level)
            outfile.write('ImageValue=model_.ImageDisplayParameterValueType(\n')
            self.ImageValue.exportLiteral(outfile, level, name_='ImageValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StringValue is not None:
            showIndent(outfile, level)
            outfile.write('StringValue=%s,\n' % quote_python(self.StringValue).encode(ExternalEncoding))
        if self.NumberValue is not None:
            showIndent(outfile, level)
            outfile.write('NumberValue=%f,\n' % self.NumberValue)
        if self.BooleanValue is not None:
            showIndent(outfile, level)
            outfile.write('BooleanValue=%s,\n' % self.BooleanValue)
        if self.ColorValue is not None:
            showIndent(outfile, level)
            outfile.write('ColorValue=model_.ColorType(\n')
            self.ColorValue.exportLiteral(outfile, level, name_='ColorValue')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ImageValue':
            obj_ = ImageDisplayParameterValueType.factory()
            obj_.build(child_)
            self.set_ImageValue(obj_)
        elif nodeName_ == 'StringValue':
            StringValue_ = child_.text
            StringValue_ = self.gds_validate_string(StringValue_, node, 'StringValue')
            self.StringValue = StringValue_
        elif nodeName_ == 'NumberValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'NumberValue')
            self.NumberValue = fval_
        elif nodeName_ == 'BooleanValue':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BooleanValue')
            self.BooleanValue = ival_
        elif nodeName_ == 'ColorValue':
            obj_ = ColorType.factory()
            obj_.build(child_)
            self.set_ColorValue(obj_)
# end class ParameterValueType


class IntegerParameterValueType(ParameterValueType):
    subclass = None
    superclass = ParameterValueType
    def __init__(self, Name=None, ImageValue=None, StringValue=None, NumberValue=None, BooleanValue=None, ColorValue=None, Value=None):
        super(IntegerParameterValueType, self).__init__(Name, ImageValue, StringValue, NumberValue, BooleanValue, ColorValue, )
        self.Value = _cast(int, Value)
        pass
    def factory(*args_, **kwargs_):
        if IntegerParameterValueType.subclass:
            return IntegerParameterValueType.subclass(*args_, **kwargs_)
        else:
            return IntegerParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='ijr:', name_='IntegerParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='IntegerParameterValueType'):
        super(IntegerParameterValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntegerParameterValueType')
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            outfile.write(' Value="%s"' % self.gds_format_integer(self.Value, input_name='Value'))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='IntegerParameterValueType', fromsubclass_=False):
        super(IntegerParameterValueType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(IntegerParameterValueType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IntegerParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            showIndent(outfile, level)
            outfile.write('Value = %d,\n' % (self.Value,))
        super(IntegerParameterValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IntegerParameterValueType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            try:
                self.Value = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(IntegerParameterValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IntegerParameterValueType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IntegerParameterValueType


class DecimalParameterValueType(ParameterValueType):
    subclass = None
    superclass = ParameterValueType
    def __init__(self, Name=None, ImageValue=None, StringValue=None, NumberValue=None, BooleanValue=None, ColorValue=None, Value=None):
        super(DecimalParameterValueType, self).__init__(Name, ImageValue, StringValue, NumberValue, BooleanValue, ColorValue, )
        self.Value = _cast(float, Value)
        pass
    def factory(*args_, **kwargs_):
        if DecimalParameterValueType.subclass:
            return DecimalParameterValueType.subclass(*args_, **kwargs_)
        else:
            return DecimalParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='ijr:', name_='DecimalParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DecimalParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='DecimalParameterValueType'):
        super(DecimalParameterValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DecimalParameterValueType')
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            outfile.write(' Value="%s"' % self.gds_format_float(self.Value, input_name='Value'))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='DecimalParameterValueType', fromsubclass_=False):
        super(DecimalParameterValueType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(DecimalParameterValueType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DecimalParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            showIndent(outfile, level)
            outfile.write('Value = %f,\n' % (self.Value,))
        super(DecimalParameterValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DecimalParameterValueType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            try:
                self.Value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (Value): %s' % exp)
        super(DecimalParameterValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DecimalParameterValueType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DecimalParameterValueType


class StringParameterValueType(ParameterValueType):
    subclass = None
    superclass = ParameterValueType
    def __init__(self, Name=None, ImageValue=None, StringValue=None, NumberValue=None, BooleanValue=None, ColorValue=None, Value=None):
        super(StringParameterValueType, self).__init__(Name, ImageValue, StringValue, NumberValue, BooleanValue, ColorValue, )
        self.Value = _cast(None, Value)
        pass
    def factory(*args_, **kwargs_):
        if StringParameterValueType.subclass:
            return StringParameterValueType.subclass(*args_, **kwargs_)
        else:
            return StringParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='ijr:', name_='StringParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='StringParameterValueType'):
        super(StringParameterValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StringParameterValueType')
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            outfile.write(' Value=%s' % (self.gds_format_string(quote_attrib(self.Value).encode(ExternalEncoding), input_name='Value'), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='StringParameterValueType', fromsubclass_=False):
        super(StringParameterValueType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(StringParameterValueType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StringParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            showIndent(outfile, level)
            outfile.write('Value = "%s",\n' % (self.Value,))
        super(StringParameterValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StringParameterValueType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.append('Value')
            self.Value = value
        super(StringParameterValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(StringParameterValueType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StringParameterValueType


class ImageDisplayParameterValueType(GeneratedsSuper):
    """A display parameter value marshalls an image and associated overlays
    to ImageJ. A new display is created using the display service.
    The ImageID has the name of the display's NDImage. The NDImage
    is stored as a separate Mime part as part of the multipart
    message."""
    subclass = None
    superclass = None
    def __init__(self, ImageName=None, ImageID=None, Overlay=None, Axis=None):
        self.ImageName = _cast(None, ImageName)
        self.ImageID = _cast(None, ImageID)
        if Overlay is None:
            self.Overlay = []
        else:
            self.Overlay = Overlay
        if Axis is None:
            self.Axis = []
        else:
            self.Axis = Axis
    def factory(*args_, **kwargs_):
        if ImageDisplayParameterValueType.subclass:
            return ImageDisplayParameterValueType.subclass(*args_, **kwargs_)
        else:
            return ImageDisplayParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Overlay(self): return self.Overlay
    def set_Overlay(self, Overlay): self.Overlay = Overlay
    def add_Overlay(self, value): self.Overlay.append(value)
    def insert_Overlay(self, index, value): self.Overlay[index] = value
    def get_Axis(self): return self.Axis
    def set_Axis(self, Axis): self.Axis = Axis
    def add_Axis(self, value): self.Axis.append(value)
    def insert_Axis(self, index, value): self.Axis[index] = value
    def get_ImageName(self): return self.ImageName
    def set_ImageName(self, ImageName): self.ImageName = ImageName
    def get_ImageID(self): return self.ImageID
    def set_ImageID(self, ImageID): self.ImageID = ImageID
    def export(self, outfile, level, namespace_='ijr:', name_='ImageDisplayParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageDisplayParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ImageDisplayParameterValueType'):
        if self.ImageName is not None and 'ImageName' not in already_processed:
            already_processed.append('ImageName')
            outfile.write(' ImageName=%s' % (self.gds_format_string(quote_attrib(self.ImageName).encode(ExternalEncoding), input_name='ImageName'), ))
        if self.ImageID is not None and 'ImageID' not in already_processed:
            already_processed.append('ImageID')
            outfile.write(' ImageID=%s' % (quote_attrib(self.ImageID), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ImageDisplayParameterValueType', fromsubclass_=False):
        for Overlay_ in self.Overlay:
            Overlay_.export(outfile, level, namespace_, name_='Overlay')
        for Axis_ in self.Axis:
            showIndent(outfile, level)
            outfile.write('<%sAxis>%s</%sAxis>\n' % (namespace_, self.gds_format_string(quote_xml(Axis_).encode(ExternalEncoding), input_name='Axis'), namespace_))
    def hasContent_(self):
        if (
            self.Overlay or
            self.Axis
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImageDisplayParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ImageName is not None and 'ImageName' not in already_processed:
            already_processed.append('ImageName')
            showIndent(outfile, level)
            outfile.write('ImageName = "%s",\n' % (self.ImageName,))
        if self.ImageID is not None and 'ImageID' not in already_processed:
            already_processed.append('ImageID')
            showIndent(outfile, level)
            outfile.write('ImageID = "%s",\n' % (self.ImageID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Overlay=[\n')
        level += 1
        for Overlay_ in self.Overlay:
            showIndent(outfile, level)
            outfile.write('model_.OverlayType(\n')
            Overlay_.exportLiteral(outfile, level, name_='OverlayType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Axis=[\n')
        level += 1
        for Axis_ in self.Axis:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Axis_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ImageName', node)
        if value is not None and 'ImageName' not in already_processed:
            already_processed.append('ImageName')
            self.ImageName = value
        value = find_attr_value_('ImageID', node)
        if value is not None and 'ImageID' not in already_processed:
            already_processed.append('ImageID')
            self.ImageID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Overlay':
            obj_ = OverlayType.factory()
            obj_.build(child_)
            self.Overlay.append(obj_)
        elif nodeName_ == 'Axis':
            Axis_ = child_.text
            Axis_ = self.gds_validate_string(Axis_, node, 'Axis')
            self.Axis.append(Axis_)
# end class ImageDisplayParameterValueType


class Axis(GeneratedsSuper):
    """The axis names in order of appearance in the array."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Axis.subclass:
            return Axis.subclass(*args_, **kwargs_)
        else:
            return Axis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='Axis', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Axis')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='Axis'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='Axis', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Axis'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Axis


class RunModuleRequestType(ContextRequestType):
    """Obtain a context ID from Subimager using the CreateContextRequest.
    Subimager uses the ImageJ context to get the DisplayService and
    ModuleService that are used during this call. The ModuleID from
    the corresponding module in the GetModulesResponse."""
    subclass = None
    superclass = ContextRequestType
    def __init__(self, ContextID=None, ModuleID=None, Parameter=None):
        super(RunModuleRequestType, self).__init__(ContextID, )
        self.ModuleID = _cast(None, ModuleID)
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if RunModuleRequestType.subclass:
            return RunModuleRequestType.subclass(*args_, **kwargs_)
        else:
            return RunModuleRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter(self, index, value): self.Parameter[index] = value
    def get_ModuleID(self): return self.ModuleID
    def set_ModuleID(self, ModuleID): self.ModuleID = ModuleID
    def export(self, outfile, level, namespace_='ijr:', name_='RunModuleRequestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RunModuleRequestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='RunModuleRequestType'):
        super(RunModuleRequestType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RunModuleRequestType')
        if self.ModuleID is not None and 'ModuleID' not in already_processed:
            already_processed.append('ModuleID')
            outfile.write(' ModuleID=%s' % (quote_attrib(self.ModuleID), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='RunModuleRequestType', fromsubclass_=False):
        super(RunModuleRequestType, self).exportChildren(outfile, level, namespace_, name_, True)
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter')
    def hasContent_(self):
        if (
            self.Parameter or
            super(RunModuleRequestType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RunModuleRequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ModuleID is not None and 'ModuleID' not in already_processed:
            already_processed.append('ModuleID')
            showIndent(outfile, level)
            outfile.write('ModuleID = "%s",\n' % (self.ModuleID,))
        super(RunModuleRequestType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RunModuleRequestType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.ParameterValueType(\n')
            Parameter_.exportLiteral(outfile, level, name_='ParameterValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ModuleID', node)
        if value is not None and 'ModuleID' not in already_processed:
            already_processed.append('ModuleID')
            self.ModuleID = value
        super(RunModuleRequestType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Parameter':
            class_obj_ = self.get_class_obj_(child_, ParameterValueType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
        super(RunModuleRequestType, self).buildChildren(child_, node, nodeName_, True)
# end class RunModuleRequestType


class RunModuleResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Exception=None, Parameter=None):
        self.Exception = Exception
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if RunModuleResponseType.subclass:
            return RunModuleResponseType.subclass(*args_, **kwargs_)
        else:
            return RunModuleResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Exception(self): return self.Exception
    def set_Exception(self, Exception): self.Exception = Exception
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter(self, index, value): self.Parameter[index] = value
    def export(self, outfile, level, namespace_='ijr:', name_='RunModuleResponseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RunModuleResponseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='RunModuleResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='RunModuleResponseType', fromsubclass_=False):
        if self.Exception is not None:
            self.Exception.export(outfile, level, namespace_, name_='Exception', )
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter')
    def hasContent_(self):
        if (
            self.Exception is not None or
            self.Parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RunModuleResponseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Exception is not None:
            showIndent(outfile, level)
            outfile.write('Exception=model_.ExceptionResponseType(\n')
            self.Exception.exportLiteral(outfile, level, name_='Exception')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.ParameterValueType(\n')
            Parameter_.exportLiteral(outfile, level, name_='ParameterValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Exception':
            obj_ = ExceptionResponseType.factory()
            obj_.build(child_)
            self.set_Exception(obj_)
        elif nodeName_ == 'Parameter':
            class_obj_ = self.get_class_obj_(child_, ParameterValueType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
# end class RunModuleResponseType


class ColorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Blue=None, Alpha=None, Green=None, Red=None):
        self.Blue = _cast(int, Blue)
        self.Alpha = _cast(int, Alpha)
        self.Green = _cast(int, Green)
        self.Red = _cast(int, Red)
        pass
    def factory(*args_, **kwargs_):
        if ColorType.subclass:
            return ColorType.subclass(*args_, **kwargs_)
        else:
            return ColorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Blue(self): return self.Blue
    def set_Blue(self, Blue): self.Blue = Blue
    def get_Alpha(self): return self.Alpha
    def set_Alpha(self, Alpha): self.Alpha = Alpha
    def get_Green(self): return self.Green
    def set_Green(self, Green): self.Green = Green
    def get_Red(self): return self.Red
    def set_Red(self, Red): self.Red = Red
    def export(self, outfile, level, namespace_='ijr:', name_='ColorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ColorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ColorType'):
        if self.Blue is not None and 'Blue' not in already_processed:
            already_processed.append('Blue')
            outfile.write(' Blue="%s"' % self.gds_format_integer(self.Blue, input_name='Blue'))
        if self.Alpha is not None and 'Alpha' not in already_processed:
            already_processed.append('Alpha')
            outfile.write(' Alpha="%s"' % self.gds_format_integer(self.Alpha, input_name='Alpha'))
        if self.Green is not None and 'Green' not in already_processed:
            already_processed.append('Green')
            outfile.write(' Green="%s"' % self.gds_format_integer(self.Green, input_name='Green'))
        if self.Red is not None and 'Red' not in already_processed:
            already_processed.append('Red')
            outfile.write(' Red="%s"' % self.gds_format_integer(self.Red, input_name='Red'))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ColorType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ColorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Blue is not None and 'Blue' not in already_processed:
            already_processed.append('Blue')
            showIndent(outfile, level)
            outfile.write('Blue = %d,\n' % (self.Blue,))
        if self.Alpha is not None and 'Alpha' not in already_processed:
            already_processed.append('Alpha')
            showIndent(outfile, level)
            outfile.write('Alpha = %d,\n' % (self.Alpha,))
        if self.Green is not None and 'Green' not in already_processed:
            already_processed.append('Green')
            showIndent(outfile, level)
            outfile.write('Green = %d,\n' % (self.Green,))
        if self.Red is not None and 'Red' not in already_processed:
            already_processed.append('Red')
            showIndent(outfile, level)
            outfile.write('Red = %d,\n' % (self.Red,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Blue', node)
        if value is not None and 'Blue' not in already_processed:
            already_processed.append('Blue')
            try:
                self.Blue = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Alpha', node)
        if value is not None and 'Alpha' not in already_processed:
            already_processed.append('Alpha')
            try:
                self.Alpha = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Green', node)
        if value is not None and 'Green' not in already_processed:
            already_processed.append('Green')
            try:
                self.Green = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Red', node)
        if value is not None and 'Red' not in already_processed:
            already_processed.append('Red')
            try:
                self.Red = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ColorType


class ChoicesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Choice=None):
        if Choice is None:
            self.Choice = []
        else:
            self.Choice = Choice
    def factory(*args_, **kwargs_):
        if ChoicesType.subclass:
            return ChoicesType.subclass(*args_, **kwargs_)
        else:
            return ChoicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Choice(self): return self.Choice
    def set_Choice(self, Choice): self.Choice = Choice
    def add_Choice(self, value): self.Choice.append(value)
    def insert_Choice(self, index, value): self.Choice[index] = value
    def export(self, outfile, level, namespace_='ijr:', name_='ChoicesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChoicesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ChoicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ChoicesType', fromsubclass_=False):
        for Choice_ in self.Choice:
            showIndent(outfile, level)
            outfile.write('<%sChoice>%s</%sChoice>\n' % (namespace_, self.gds_format_string(quote_xml(Choice_).encode(ExternalEncoding), input_name='Choice'), namespace_))
    def hasContent_(self):
        if (
            self.Choice
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChoicesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Choice=[\n')
        level += 1
        for Choice_ in self.Choice:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Choice_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Choice':
            Choice_ = child_.text
            Choice_ = self.gds_validate_string(Choice_, node, 'Choice')
            self.Choice.append(Choice_)
# end class ChoicesType


class MenuPathType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, menu_entry=None):
        if menu_entry is None:
            self.menu_entry = []
        else:
            self.menu_entry = menu_entry
    def factory(*args_, **kwargs_):
        if MenuPathType.subclass:
            return MenuPathType.subclass(*args_, **kwargs_)
        else:
            return MenuPathType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_menu_entry(self): return self.menu_entry
    def set_menu_entry(self, menu_entry): self.menu_entry = menu_entry
    def add_menu_entry(self, value): self.menu_entry.append(value)
    def insert_menu_entry(self, index, value): self.menu_entry[index] = value
    def export(self, outfile, level, namespace_='ijr:', name_='MenuPathType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MenuPathType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='MenuPathType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='MenuPathType', fromsubclass_=False):
        for menu_entry_ in self.menu_entry:
            menu_entry_.export(outfile, level, namespace_, name_='menu-entry')
    def hasContent_(self):
        if (
            self.menu_entry
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MenuPathType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('menu_entry=[\n')
        level += 1
        for menu_entry_ in self.menu_entry:
            showIndent(outfile, level)
            outfile.write('model_.MenuEntryType(\n')
            menu_entry_.exportLiteral(outfile, level, name_='MenuEntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'menu-entry':
            obj_ = MenuEntryType.factory()
            obj_.build(child_)
            self.menu_entry.append(obj_)
# end class MenuPathType


class OverlayType(GeneratedsSuper):
    """The overlay type indicates how the NDImage should be converted to an
    overlay. Type = BinaryMask indicates that the NDImage should be
    treated as a single overlay with all non-zero values marking
    pixels that are in the set. Type = Labeling indicates that the
    NDImage should be converted to integer values and pixels with
    non-zero values should be distinct overlays. Labeling can be
    done with an Imglib Labeling."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Name=None):
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.Name = Name
    def factory(*args_, **kwargs_):
        if OverlayType.subclass:
            return OverlayType.subclass(*args_, **kwargs_)
        else:
            return OverlayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='ijr:', name_='OverlayType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OverlayType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='OverlayType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='OverlayType', fromsubclass_=False):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_))
    def hasContent_(self):
        if (
            self.Name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OverlayType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
# end class OverlayType


class GetModulesRequestType(ContextRequestType):
    subclass = None
    superclass = ContextRequestType
    def __init__(self, ContextID=None):
        super(GetModulesRequestType, self).__init__(ContextID, )
        pass
    def factory(*args_, **kwargs_):
        if GetModulesRequestType.subclass:
            return GetModulesRequestType.subclass(*args_, **kwargs_)
        else:
            return GetModulesRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='GetModulesRequestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GetModulesRequestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='GetModulesRequestType'):
        super(GetModulesRequestType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GetModulesRequestType')
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='GetModulesRequestType', fromsubclass_=False):
        super(GetModulesRequestType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(GetModulesRequestType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GetModulesRequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GetModulesRequestType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GetModulesRequestType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GetModulesRequestType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GetModulesRequestType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GetModulesRequestType


class ModuleInfoType(BasicDetailsType):
    """The module ID identifies a module within the scope of the context.
    The client should set the module ID in a run module request to
    the module ID of the desired module in a prior get modules
    response."""
    subclass = None
    superclass = BasicDetailsType
    def __init__(self, Name=None, Label=None, Description=None, MenuRoot=None, IsEnabled=None, Priority=None, IsSelected=None, IsSelectable=None, SelectionGroup=None, IconPath=None, CanRunHeadless=None, ModuleID=None, Title=None, MenuPath=None, Input=None, Output=None):
        super(ModuleInfoType, self).__init__(Name, Label, Description, )
        self.MenuRoot = _cast(None, MenuRoot)
        self.IsEnabled = _cast(bool, IsEnabled)
        self.Priority = _cast(float, Priority)
        self.IsSelected = _cast(bool, IsSelected)
        self.IsSelectable = _cast(bool, IsSelectable)
        self.SelectionGroup = _cast(None, SelectionGroup)
        self.IconPath = _cast(None, IconPath)
        self.CanRunHeadless = _cast(bool, CanRunHeadless)
        self.ModuleID = _cast(None, ModuleID)
        self.Title = Title
        self.MenuPath = MenuPath
        if Input is None:
            self.Input = []
        else:
            self.Input = Input
        if Output is None:
            self.Output = []
        else:
            self.Output = Output
    def factory(*args_, **kwargs_):
        if ModuleInfoType.subclass:
            return ModuleInfoType.subclass(*args_, **kwargs_)
        else:
            return ModuleInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_MenuPath(self): return self.MenuPath
    def set_MenuPath(self, MenuPath): self.MenuPath = MenuPath
    def get_Input(self): return self.Input
    def set_Input(self, Input): self.Input = Input
    def add_Input(self, value): self.Input.append(value)
    def insert_Input(self, index, value): self.Input[index] = value
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def add_Output(self, value): self.Output.append(value)
    def insert_Output(self, index, value): self.Output[index] = value
    def get_MenuRoot(self): return self.MenuRoot
    def set_MenuRoot(self, MenuRoot): self.MenuRoot = MenuRoot
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Priority(self): return self.Priority
    def set_Priority(self, Priority): self.Priority = Priority
    def get_IsSelected(self): return self.IsSelected
    def set_IsSelected(self, IsSelected): self.IsSelected = IsSelected
    def get_IsSelectable(self): return self.IsSelectable
    def set_IsSelectable(self, IsSelectable): self.IsSelectable = IsSelectable
    def get_SelectionGroup(self): return self.SelectionGroup
    def set_SelectionGroup(self, SelectionGroup): self.SelectionGroup = SelectionGroup
    def get_IconPath(self): return self.IconPath
    def set_IconPath(self, IconPath): self.IconPath = IconPath
    def get_CanRunHeadless(self): return self.CanRunHeadless
    def set_CanRunHeadless(self, CanRunHeadless): self.CanRunHeadless = CanRunHeadless
    def get_ModuleID(self): return self.ModuleID
    def set_ModuleID(self, ModuleID): self.ModuleID = ModuleID
    def export(self, outfile, level, namespace_='ijr:', name_='ModuleInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleInfoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ModuleInfoType'):
        super(ModuleInfoType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleInfoType')
        if self.MenuRoot is not None and 'MenuRoot' not in already_processed:
            already_processed.append('MenuRoot')
            outfile.write(' MenuRoot=%s' % (self.gds_format_string(quote_attrib(self.MenuRoot).encode(ExternalEncoding), input_name='MenuRoot'), ))
        if self.IsEnabled is not None and 'IsEnabled' not in already_processed:
            already_processed.append('IsEnabled')
            outfile.write(' IsEnabled="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.IsEnabled)), input_name='IsEnabled'))
        if self.Priority is not None and 'Priority' not in already_processed:
            already_processed.append('Priority')
            outfile.write(' Priority="%s"' % self.gds_format_double(self.Priority, input_name='Priority'))
        if self.IsSelected is not None and 'IsSelected' not in already_processed:
            already_processed.append('IsSelected')
            outfile.write(' IsSelected="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.IsSelected)), input_name='IsSelected'))
        if self.IsSelectable is not None and 'IsSelectable' not in already_processed:
            already_processed.append('IsSelectable')
            outfile.write(' IsSelectable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.IsSelectable)), input_name='IsSelectable'))
        if self.SelectionGroup is not None and 'SelectionGroup' not in already_processed:
            already_processed.append('SelectionGroup')
            outfile.write(' SelectionGroup=%s' % (self.gds_format_string(quote_attrib(self.SelectionGroup).encode(ExternalEncoding), input_name='SelectionGroup'), ))
        if self.IconPath is not None and 'IconPath' not in already_processed:
            already_processed.append('IconPath')
            outfile.write(' IconPath=%s' % (self.gds_format_string(quote_attrib(self.IconPath).encode(ExternalEncoding), input_name='IconPath'), ))
        if self.CanRunHeadless is not None and 'CanRunHeadless' not in already_processed:
            already_processed.append('CanRunHeadless')
            outfile.write(' CanRunHeadless="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.CanRunHeadless)), input_name='CanRunHeadless'))
        if self.ModuleID is not None and 'ModuleID' not in already_processed:
            already_processed.append('ModuleID')
            outfile.write(' ModuleID=%s' % (quote_attrib(self.ModuleID), ))
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ModuleInfoType', fromsubclass_=False):
        super(ModuleInfoType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('<%sTitle>%s</%sTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_))
        if self.MenuPath is not None:
            self.MenuPath.export(outfile, level, namespace_, name_='MenuPath')
        for Input_ in self.Input:
            Input_.export(outfile, level, namespace_, name_='Input')
        for Output_ in self.Output:
            Output_.export(outfile, level, namespace_, name_='Output')
    def hasContent_(self):
        if (
            self.Title is not None or
            self.MenuPath is not None or
            self.Input or
            self.Output or
            super(ModuleInfoType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ModuleInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MenuRoot is not None and 'MenuRoot' not in already_processed:
            already_processed.append('MenuRoot')
            showIndent(outfile, level)
            outfile.write('MenuRoot = "%s",\n' % (self.MenuRoot,))
        if self.IsEnabled is not None and 'IsEnabled' not in already_processed:
            already_processed.append('IsEnabled')
            showIndent(outfile, level)
            outfile.write('IsEnabled = %s,\n' % (self.IsEnabled,))
        if self.Priority is not None and 'Priority' not in already_processed:
            already_processed.append('Priority')
            showIndent(outfile, level)
            outfile.write('Priority = %e,\n' % (self.Priority,))
        if self.IsSelected is not None and 'IsSelected' not in already_processed:
            already_processed.append('IsSelected')
            showIndent(outfile, level)
            outfile.write('IsSelected = %s,\n' % (self.IsSelected,))
        if self.IsSelectable is not None and 'IsSelectable' not in already_processed:
            already_processed.append('IsSelectable')
            showIndent(outfile, level)
            outfile.write('IsSelectable = %s,\n' % (self.IsSelectable,))
        if self.SelectionGroup is not None and 'SelectionGroup' not in already_processed:
            already_processed.append('SelectionGroup')
            showIndent(outfile, level)
            outfile.write('SelectionGroup = "%s",\n' % (self.SelectionGroup,))
        if self.IconPath is not None and 'IconPath' not in already_processed:
            already_processed.append('IconPath')
            showIndent(outfile, level)
            outfile.write('IconPath = "%s",\n' % (self.IconPath,))
        if self.CanRunHeadless is not None and 'CanRunHeadless' not in already_processed:
            already_processed.append('CanRunHeadless')
            showIndent(outfile, level)
            outfile.write('CanRunHeadless = %s,\n' % (self.CanRunHeadless,))
        if self.ModuleID is not None and 'ModuleID' not in already_processed:
            already_processed.append('ModuleID')
            showIndent(outfile, level)
            outfile.write('ModuleID = "%s",\n' % (self.ModuleID,))
        super(ModuleInfoType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ModuleInfoType, self).exportLiteralChildren(outfile, level, name_)
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.MenuPath is not None:
            showIndent(outfile, level)
            outfile.write('MenuPath=model_.MenuPathType(\n')
            self.MenuPath.exportLiteral(outfile, level, name_='MenuPath')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Input=[\n')
        level += 1
        for Input_ in self.Input:
            showIndent(outfile, level)
            outfile.write('model_.ModuleItemType(\n')
            Input_.exportLiteral(outfile, level, name_='ModuleItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Output=[\n')
        level += 1
        for Output_ in self.Output:
            showIndent(outfile, level)
            outfile.write('model_.ModuleItemType(\n')
            Output_.exportLiteral(outfile, level, name_='ModuleItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MenuRoot', node)
        if value is not None and 'MenuRoot' not in already_processed:
            already_processed.append('MenuRoot')
            self.MenuRoot = value
        value = find_attr_value_('IsEnabled', node)
        if value is not None and 'IsEnabled' not in already_processed:
            already_processed.append('IsEnabled')
            if value in ('true', '1'):
                self.IsEnabled = True
            elif value in ('false', '0'):
                self.IsEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Priority', node)
        if value is not None and 'Priority' not in already_processed:
            already_processed.append('Priority')
            try:
                self.Priority = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (Priority): %s' % exp)
        value = find_attr_value_('IsSelected', node)
        if value is not None and 'IsSelected' not in already_processed:
            already_processed.append('IsSelected')
            if value in ('true', '1'):
                self.IsSelected = True
            elif value in ('false', '0'):
                self.IsSelected = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('IsSelectable', node)
        if value is not None and 'IsSelectable' not in already_processed:
            already_processed.append('IsSelectable')
            if value in ('true', '1'):
                self.IsSelectable = True
            elif value in ('false', '0'):
                self.IsSelectable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SelectionGroup', node)
        if value is not None and 'SelectionGroup' not in already_processed:
            already_processed.append('SelectionGroup')
            self.SelectionGroup = value
        value = find_attr_value_('IconPath', node)
        if value is not None and 'IconPath' not in already_processed:
            already_processed.append('IconPath')
            self.IconPath = value
        value = find_attr_value_('CanRunHeadless', node)
        if value is not None and 'CanRunHeadless' not in already_processed:
            already_processed.append('CanRunHeadless')
            if value in ('true', '1'):
                self.CanRunHeadless = True
            elif value in ('false', '0'):
                self.CanRunHeadless = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ModuleID', node)
        if value is not None and 'ModuleID' not in already_processed:
            already_processed.append('ModuleID')
            self.ModuleID = value
        super(ModuleInfoType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'MenuPath':
            obj_ = MenuPathType.factory()
            obj_.build(child_)
            self.set_MenuPath(obj_)
        elif nodeName_ == 'Input':
            obj_ = ModuleItemType.factory()
            obj_.build(child_)
            self.Input.append(obj_)
        elif nodeName_ == 'Output':
            obj_ = ModuleItemType.factory()
            obj_.build(child_)
            self.Output.append(obj_)
        super(ModuleInfoType, self).buildChildren(child_, node, nodeName_, True)
# end class ModuleInfoType


class ModuleItemType(BasicDetailsType):
    subclass = None
    superclass = BasicDetailsType
    def __init__(self, Name=None, Label=None, Description=None, Type=None, IOType=None, Visibility=None, WidgetStyle=None, MinimumValue=None, MaximumValue=None, StepSize=None, ColumnCount=None, Choices=None):
        super(ModuleItemType, self).__init__(Name, Label, Description, )
        self.Type = Type
        self.IOType = IOType
        self.Visibility = Visibility
        self.WidgetStyle = WidgetStyle
        self.MinimumValue = MinimumValue
        self.MaximumValue = MaximumValue
        self.StepSize = StepSize
        self.ColumnCount = ColumnCount
        self.Choices = Choices
    def factory(*args_, **kwargs_):
        if ModuleItemType.subclass:
            return ModuleItemType.subclass(*args_, **kwargs_)
        else:
            return ModuleItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_IOType(self): return self.IOType
    def set_IOType(self, IOType): self.IOType = IOType
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def get_WidgetStyle(self): return self.WidgetStyle
    def set_WidgetStyle(self, WidgetStyle): self.WidgetStyle = WidgetStyle
    def get_MinimumValue(self): return self.MinimumValue
    def set_MinimumValue(self, MinimumValue): self.MinimumValue = MinimumValue
    def get_MaximumValue(self): return self.MaximumValue
    def set_MaximumValue(self, MaximumValue): self.MaximumValue = MaximumValue
    def get_StepSize(self): return self.StepSize
    def set_StepSize(self, StepSize): self.StepSize = StepSize
    def get_ColumnCount(self): return self.ColumnCount
    def set_ColumnCount(self, ColumnCount): self.ColumnCount = ColumnCount
    def get_Choices(self): return self.Choices
    def set_Choices(self, Choices): self.Choices = Choices
    def export(self, outfile, level, namespace_='ijr:', name_='ModuleItemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleItemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='ModuleItemType'):
        super(ModuleItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ModuleItemType')
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='ModuleItemType', fromsubclass_=False):
        super(ModuleItemType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_))
        if self.IOType is not None:
            showIndent(outfile, level)
            outfile.write('<%sIOType>%s</%sIOType>\n' % (namespace_, self.gds_format_string(quote_xml(self.IOType).encode(ExternalEncoding), input_name='IOType'), namespace_))
        if self.Visibility is not None:
            showIndent(outfile, level)
            outfile.write('<%sVisibility>%s</%sVisibility>\n' % (namespace_, self.gds_format_string(quote_xml(self.Visibility).encode(ExternalEncoding), input_name='Visibility'), namespace_))
        if self.WidgetStyle is not None:
            showIndent(outfile, level)
            outfile.write('<%sWidgetStyle>%s</%sWidgetStyle>\n' % (namespace_, self.gds_format_string(quote_xml(self.WidgetStyle).encode(ExternalEncoding), input_name='WidgetStyle'), namespace_))
        if self.MinimumValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sMinimumValue>%s</%sMinimumValue>\n' % (namespace_, self.gds_format_float(self.MinimumValue, input_name='MinimumValue'), namespace_))
        if self.MaximumValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaximumValue>%s</%sMaximumValue>\n' % (namespace_, self.gds_format_float(self.MaximumValue, input_name='MaximumValue'), namespace_))
        if self.StepSize is not None:
            showIndent(outfile, level)
            outfile.write('<%sStepSize>%s</%sStepSize>\n' % (namespace_, self.gds_format_float(self.StepSize, input_name='StepSize'), namespace_))
        if self.ColumnCount is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnCount>%s</%sColumnCount>\n' % (namespace_, self.gds_format_integer(self.ColumnCount, input_name='ColumnCount'), namespace_))
        if self.Choices is not None:
            self.Choices.export(outfile, level, namespace_, name_='Choices')
    def hasContent_(self):
        if (
            self.Type is not None or
            self.IOType is not None or
            self.Visibility is not None or
            self.WidgetStyle is not None or
            self.MinimumValue is not None or
            self.MaximumValue is not None or
            self.StepSize is not None or
            self.ColumnCount is not None or
            self.Choices is not None or
            super(ModuleItemType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ModuleItemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ModuleItemType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ModuleItemType, self).exportLiteralChildren(outfile, level, name_)
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.IOType is not None:
            showIndent(outfile, level)
            outfile.write('IOType=%s,\n' % quote_python(self.IOType).encode(ExternalEncoding))
        if self.Visibility is not None:
            showIndent(outfile, level)
            outfile.write('Visibility=%s,\n' % quote_python(self.Visibility).encode(ExternalEncoding))
        if self.WidgetStyle is not None:
            showIndent(outfile, level)
            outfile.write('WidgetStyle=%s,\n' % quote_python(self.WidgetStyle).encode(ExternalEncoding))
        if self.MinimumValue is not None:
            showIndent(outfile, level)
            outfile.write('MinimumValue=%f,\n' % self.MinimumValue)
        if self.MaximumValue is not None:
            showIndent(outfile, level)
            outfile.write('MaximumValue=%f,\n' % self.MaximumValue)
        if self.StepSize is not None:
            showIndent(outfile, level)
            outfile.write('StepSize=%f,\n' % self.StepSize)
        if self.ColumnCount is not None:
            showIndent(outfile, level)
            outfile.write('ColumnCount=%d,\n' % self.ColumnCount)
        if self.Choices is not None:
            showIndent(outfile, level)
            outfile.write('Choices=model_.ChoicesType(\n')
            self.Choices.exportLiteral(outfile, level, name_='Choices')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ModuleItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'IOType':
            IOType_ = child_.text
            IOType_ = self.gds_validate_string(IOType_, node, 'IOType')
            self.IOType = IOType_
        elif nodeName_ == 'Visibility':
            Visibility_ = child_.text
            Visibility_ = self.gds_validate_string(Visibility_, node, 'Visibility')
            self.Visibility = Visibility_
        elif nodeName_ == 'WidgetStyle':
            WidgetStyle_ = child_.text
            WidgetStyle_ = self.gds_validate_string(WidgetStyle_, node, 'WidgetStyle')
            self.WidgetStyle = WidgetStyle_
        elif nodeName_ == 'MinimumValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MinimumValue')
            self.MinimumValue = fval_
        elif nodeName_ == 'MaximumValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaximumValue')
            self.MaximumValue = fval_
        elif nodeName_ == 'StepSize':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'StepSize')
            self.StepSize = fval_
        elif nodeName_ == 'ColumnCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnCount')
            self.ColumnCount = ival_
        elif nodeName_ == 'Choices':
            obj_ = ChoicesType.factory()
            obj_.build(child_)
            self.set_Choices(obj_)
        super(ModuleItemType, self).buildChildren(child_, node, nodeName_, True)
# end class ModuleItemType


class DestroyContextRequestType(ContextRequestType):
    subclass = None
    superclass = ContextRequestType
    def __init__(self, ContextID=None):
        super(DestroyContextRequestType, self).__init__(ContextID, )
        pass
    def factory(*args_, **kwargs_):
        if DestroyContextRequestType.subclass:
            return DestroyContextRequestType.subclass(*args_, **kwargs_)
        else:
            return DestroyContextRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='ijr:', name_='DestroyContextRequestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestroyContextRequestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='ijr:', name_='DestroyContextRequestType'):
        super(DestroyContextRequestType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DestroyContextRequestType')
    def exportChildren(self, outfile, level, namespace_='ijr:', name_='DestroyContextRequestType', fromsubclass_=False):
        super(DestroyContextRequestType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(DestroyContextRequestType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DestroyContextRequestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DestroyContextRequestType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DestroyContextRequestType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(DestroyContextRequestType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DestroyContextRequestType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DestroyContextRequestType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    if tag.lower() == "request":
        rootClass = RequestType
    elif tag.lower() == "response":
        rootClass = ResponseType
    else:
        rootClass = None
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RequestType'
        rootClass = RequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RequestType'
        rootClass = RequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RequestType'
        rootClass = RequestType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from imagejrequest import *\n\n')
    sys.stdout.write('import imagejrequest as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AcceleratorType",
    "Axis",
    "BasicDetailsType",
    "ChoicesType",
    "ColorType",
    "ContextRequestType",
    "ContextType",
    "CreateContextRequestType",
    "CreateContextResponseType",
    "DecimalParameterValueType",
    "DestroyContextRequestType",
    "ExceptionResponseType",
    "GetModulesRequestType",
    "GetModulesResponseType",
    "IOType",
    "ImageDisplayParameterValueType",
    "IntegerParameterValueType",
    "MenuEntryType",
    "MenuPathType",
    "Mnemonic",
    "ModuleInfoType",
    "ModuleItemType",
    "OverlayType",
    "ParameterValueType",
    "RequestType",
    "ResponseType",
    "RunModuleRequestType",
    "RunModuleResponseType",
    "StringParameterValueType",
    "Type",
    "Visibility",
    "WidgetStyle"
    ]
