""" cpmorphology.py - morphological operations not in scipy

"""
__version__="$Revision: 1 "

import numpy
import scipy.ndimage
import _cpmorphology 

def fill_labeled_holes(image):
    """Fill holes in objects in a labeled image
    
    image - a label matrix, for instance as generated by scipy.ndimage.label
    This algorithm takes a labeled image and fills any hole (unlabeled 
    pixels surrounded solely by one label). The key insight is that if
    you generate a binary image composed of the unlabeled points and
    you label it, each hole gets a unique label. After that, you can get
    rid of any labeled "hole" that's touching the border and any labeled
    "hole" that's touching more than one labeled object (space between two
    touching objects). A further trick is to figure out whether a hole
    touches more than one object or the edge. To get the min and the max,
    ignoring the holes, we label the holes as zero in the labeled image
    for the max (already done) and label them with infinity (more or less)
    when doing the min. Finally, we can get rid of the "holes" touching
    the border by labeling the border with zero (by choosing a mode of
    "constant" and a cval of zero) so that their min will differ from
    the maximum object they touch.
    
    If you 8-connect objects, then you must 4-connect the holes to
    keep holes like the following from connecting with the outside world:
    * 1 *
    1 @ 1
    * 1 *
    where * is outside background, @ is inside background and 1 is foreground.
    """
    four_connect = scipy.ndimage.generate_binary_structure(2, 1)
    negative_mask = (image == 0)
    labeled_holes, nholes = scipy.ndimage.label(negative_mask,four_connect)
    image_with_high_holes = image.copy()
    image_with_high_holes[labeled_holes > 0] = 1000000000
    min_label = scipy.ndimage.minimum_filter(image_with_high_holes,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    max_label = scipy.ndimage.maximum_filter(image,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    min_label_per_hole = scipy.ndimage.minimum(min_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = scipy.ndimage.maximum(max_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = numpy.array(max_label_per_hole)
    hole_label = numpy.array(min_label_per_hole)
    hole_label[hole_label != max_label_per_hole] = 0
    hole_mask = hole_label[labeled_holes] > 0
    output_image = image.copy()
    output_image[hole_mask] = hole_label[labeled_holes[hole_mask]]
    return output_image

def binary_thin(image, strel1, strel2):
    """Morphologically thin an image
    strel1 - the required values of the pixels in order to survive
    strel2 - at each pixel, the complement of strel1 if we care about the value
    """
    hit_or_miss = scipy.ndimage.binary_hit_or_miss(image, strel1, strel2)
    return numpy.logical_and(image,numpy.logical_not(hit_or_miss))

def binary_shrink(image, iterations=-1):
    """Shrink an image by repeatedly removing pixels which have partners
       above, to the left, to the right and below until the image doesn't change
       
       image - binary image to be manipulated
       iterations - # of times to shrink, -1 to shrink until idempotent
       
       There are horizontal/vertical thinners which detect a pixel on
       an edge with an interior pixel either horizontally or vertically
       attached like this:
       0  0  0
       X  1  X
       X  1  X
       and there are much more specific diagonal thinners which detect
       a pixel on the edge of a diagonal, like this:
       0  0  0
       0  1  0
       0  0  1
       Rotate each of these 4x to get the four directions for each
    """
    hv_thinner = numpy.array([[False,False,False],[False,True,False],[False,True,False]])
    hv_anti_thinner = numpy.array([[True,True,True],[False,False,False],[False,False,False]])
    d_thinner = numpy.array([[False,False,False],[False,True,False],[False,False,True]])
    d_anti_thinner = numpy.array([[True,True,True],[True,False,True],[True,True,False]])
    thinners = []
    anti_thinners = []
    for thinner,anti_thinner in ((hv_thinner, hv_anti_thinner),(d_thinner,d_anti_thinner)):
        for n in range(4):
            thinners.append(numpy.lib.rot90(thinner,n))
            anti_thinners.append(numpy.lib.rot90(anti_thinner,n))
    if iterations == -1:
        iterations = 10000
    result = image
    for n in range(iterations):
        temp = result.copy()
        for thinner,anti_thinner in zip(thinners,anti_thinners):
            temp = binary_thin(temp,thinner,anti_thinner)
        if numpy.all(temp==result):
            return result
        result=temp

def strel_disk(radius):
    """Create a disk structuring element for morphological operations
    
    radius - radius of the disk
    """
    iradius = int(radius)
    x,y     = numpy.mgrid[-iradius:iradius+1,-iradius:iradius+1]
    radius2 = radius * radius
    strel   = numpy.zeros(x.shape)
    strel[x*x+y*y <= radius2] = 1
    return strel

def cpmaximum(image, structure=numpy.ones((3,3),dtype=bool),offset=None):
    """Find the local maximum at each point in the image, using the given structuring element
    
    image - a 2-d array of doubles
    structure - a boolean structuring element indicating which
                local elements should be sampled
    offset - the offset to the center of the structuring element
    """
    if not offset:
        offset = (structure.shape[0]/2,structure.shape[1]/2)
    offset = tuple(offset)
    return _cpmorphology.cpmaximum(image,structure,offset)

def relabel(image):
    """Given a labeled image, relabel each of the objects consecutively
    
    image - a labeled 2-d integer array
    returns - (labeled image, object count) 
    """
    #
    # Build a label table that converts an old label # into
    # labels using the new numbering scheme
    #
    unique_labels = numpy.unique(image)
    consecutive_labels = numpy.array(range(len(unique_labels)+1))
    label_table = numpy.ndarray(((unique_labels[-1]+1),),int)
    for old,new in zip(unique_labels,consecutive_labels):
        label_table[old]=new
    #
    # Use the label table to remap all of the labels
    #
    new_image = label_table[image]
    return (new_image,len(unique_labels)-1)
