function scores = calculateScoresVect(I,D,mask,sz,step_sz,angleStep,numQuadrants,runName)
% calculate the scores matrix using the pre-preocessed and rotated images
% I,D and the externally defined functions calcF and calcScore (calcScore
% is matlab code generated by JBoost.)
    
if(nargin<7)
    numQuadrants = 4;
end

nA = size(I,2);			% number of angles
nI = size(I,1);
nD = size(D,1);

blkSize = 250;

imgH = size(I{1,1},1);
imgW = size(I{1,1},2);

scaled_mask = imresize(mask,[sz,sz])>0.5;
fprintf('Working on size %d\n',sz);

eval(sprintf('scoreFunc = @calcScore_%sVect;',runName));
%Dynamically assign the scoring function depending upon the runName

tic;
angleCount =1;
for quad = 1:numQuadrants
    for angle_i=1:nA
        curAngle = (angle_i-1)*angleStep;
        fprintf('CurAngle = %d\n',curAngle+90*(quad-1));

        [rotI rotD] = rotateImage(I,D,angle_i,quad);
        
        curImgH = size(rotI{1},1);
        curImgW = size(rotI{1},2);
        
        % To counter for matlab memory issues we calculate scores on blocks
        % of blkSize x blkSize.
            
            
        totScore = zeros(curImgH,curImgW);
        
        for xBlock=1:blkSize:curImgW-1
            for yBlock=1:blkSize:curImgH-1
                
                % Block for processing
                curBlockXmin = max(1,xBlock-sz+1);
                curBlockXmax = min(curImgW,xBlock+blkSize+sz-1);
                curBlockYmin = max(1,yBlock-sz+1);
                curBlockYmax = min(curImgH,yBlock+blkSize+sz-1);
                
                % Block of the final score image where the calculated score
                % would fit in
                
                scoreBlockXmin = xBlock;
                scoreBlockYmin = yBlock;
                scoreBlockXmax = min(curImgW,xBlock+blkSize-1);
                scoreBlockYmax = min(curImgH,yBlock+blkSize-1);
                
                % Block to read from generated score
                
                if(curBlockXmin==1)
                    scoreBlockXStart = 1;
                else
                    scoreBlockXStart = sz;
                end
                if(curBlockYmin==1)
                    scoreBlockYStart = 1;
                else
                    scoreBlockYStart = sz;
                end
                
                scoreBlockXEnd = scoreBlockXStart+length(scoreBlockXmin:scoreBlockXmax)-1;
                scoreBlockYEnd = scoreBlockYStart+length(scoreBlockYmin:scoreBlockYmax)-1;
                 
                blk = [curBlockXmin curBlockXmax curBlockYmin curBlockYmax];
                [blockrotI blockrotD] = getBlocks(rotI,rotD,blk);
                eval(sprintf('blkF = calcFVect%s(blockrotI,blockrotD,scaled_mask);',runName));
                
                [hh ww dd] = size(blkF);
                blkF = reshape(blkF,[hh*ww dd]);
                tempScore = scoreFunc(blkF);
                tempScore = reshape(tempScore,[hh ww]);

                totScore(scoreBlockYmin:scoreBlockYmax,scoreBlockXmin:scoreBlockXmax) = ...
                    tempScore(scoreBlockYStart:scoreBlockYEnd,scoreBlockXStart:scoreBlockXEnd);
                fprintf('.');
            end
            fprintf('\n');
        end

        totScore = imrotate(totScore,-(curAngle+90*(quad-1)));
        tCenter = floor(size(totScore)/2);
        totScore = totScore(tCenter(1)-floor((imgH-1)/2):tCenter(1)+floor((imgH)/2), ...
            tCenter(2)-floor((imgW-1)/2):tCenter(2)+floor((imgW)/2));
        scores{angleCount} = totScore;
        angleCount=angleCount+1;
        clear f;
    end
end
toc;
    
function [rotI rotD]= rotateImage(I,D,angle_i,quad)

rotI = {};
rotD = {};

nA = size(I,2);			% number of angles
nI = size(I,1);
nD = size(D,1);


for imgNo=1:nI
    switch quad
        case 1
            rotI{imgNo} = I{imgNo,angle_i};
        case 2
            rotI{imgNo} = fliplr(I{imgNo,angle_i})';
        case 3
            rotI{imgNo} = flipud(fliplr(I{imgNo,angle_i}));
        case 4
            rotI{imgNo} = flipud(I{imgNo,angle_i})';
    end
end
for imgNo=1:nD
    switch quad
        case 1
            rotD{imgNo}.mag = D{imgNo,angle_i}.mag;
            rotD{imgNo}.angle = D{imgNo,angle_i}.angle;
        case 2
            rotD{imgNo}.mag = fliplr(D{imgNo,angle_i}.mag)';
            rotD{imgNo}.angle = fliplr(D{imgNo,angle_i}.angle)';
            rotD{imgNo}.angle = mod(rotD{imgNo}.angle-0.25,1);
        case 3
            rotD{imgNo}.mag = flipud(fliplr(D{imgNo,angle_i}.mag));
            rotD{imgNo}.angle = flipud(fliplr(D{imgNo,angle_i}.angle));
            rotD{imgNo}.angle = mod(rotD{imgNo}.angle-0.5,1);
        case 4
            rotD{imgNo}.mag = flipud(D{imgNo,angle_i}.mag)';
            rotD{imgNo}.angle = flipud(D{imgNo,angle_i}.angle)';
            rotD{imgNo}.angle = mod(rotD{imgNo}.angle-0.75,1);
    end
end

function [blockrotI blockrotD] = getBlocks(rotI,rotD,blk)

    nI = length(rotI);
    nD = length(rotD);
    blockrotI = {};
    blockrotD = {};

    x1 = blk(1); x2 = blk(2);
    y1 = blk(3); y2 = blk(4);

    for imgNo = 1:nI
        blockrotI{imgNo} = rotI{imgNo}(y1:y2,x1:x2);
    end

    for imgNo = 1:nD
        blockrotD{imgNo}.angle =  rotD{imgNo}.angle(y1:y2,x1:x2);
        blockrotD{imgNo}.mag = rotD{imgNo}.mag(y1:y2,x1:x2);
    end