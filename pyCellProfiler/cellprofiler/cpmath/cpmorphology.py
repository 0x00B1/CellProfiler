""" cpmorphology.py - morphological operations not in scipy

"""
__version__="$Revision: 1 "

import numpy
import scipy.ndimage
import scipy.sparse
import _cpmorphology
from outline import outline 

def fill_labeled_holes(image):
    """Fill holes in objects in a labeled image
    
    image - a label matrix, for instance as generated by scipy.ndimage.label
    This algorithm takes a labeled image and fills any hole (unlabeled 
    pixels surrounded solely by one label). The key insight is that if
    you generate a binary image composed of the unlabeled points and
    you label it, each hole gets a unique label. After that, you can get
    rid of any labeled "hole" that's touching the border and any labeled
    "hole" that's touching more than one labeled object (space between two
    touching objects). A further trick is to figure out whether a hole
    touches more than one object or the edge. To get the min and the max,
    ignoring the holes, we label the holes as zero in the labeled image
    for the max (already done) and label them with infinity (more or less)
    when doing the min. Finally, we can get rid of the "holes" touching
    the border by labeling the border with zero (by choosing a mode of
    "constant" and a cval of zero) so that their min will differ from
    the maximum object they touch.
    
    If you 8-connect objects, then you must 4-connect the holes to
    keep holes like the following from connecting with the outside world:
    * 1 *
    1 @ 1
    * 1 *
    where * is outside background, @ is inside background and 1 is foreground.
    """
    four_connect = scipy.ndimage.generate_binary_structure(2, 1)
    negative_mask = (image == 0)
    labeled_holes, nholes = scipy.ndimage.label(negative_mask,four_connect)
    high = image.max()+1
    image_with_high_holes = image.copy()
    image_with_high_holes[labeled_holes > 0] = high
    min_label = scipy.ndimage.minimum_filter(image_with_high_holes,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    max_label = scipy.ndimage.maximum_filter(image,
                                             footprint=numpy.ones((3,3),bool),
                                             mode = 'constant',
                                             cval = 0)
    min_label_per_hole = scipy.ndimage.minimum(min_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = scipy.ndimage.maximum(max_label,
                                               labeled_holes,
                                               range(nholes+1))
    max_label_per_hole = numpy.array(max_label_per_hole)
    hole_label = numpy.array(min_label_per_hole)
    hole_label[hole_label != max_label_per_hole] = 0
    hole_mask = hole_label[labeled_holes] > 0
    output_image = image.copy()
    output_image[hole_mask] = hole_label[labeled_holes[hole_mask]]
    return output_image

def binary_thin(image, strel1, strel2):
    """Morphologically thin an image
    strel1 - the required values of the pixels in order to survive
    strel2 - at each pixel, the complement of strel1 if we care about the value
    """
    hit_or_miss = scipy.ndimage.binary_hit_or_miss(image, strel1, strel2)
    return numpy.logical_and(image,numpy.logical_not(hit_or_miss))

def binary_shrink(image, iterations=-1):
    """Shrink an image by repeatedly removing pixels which have partners
       above, to the left, to the right and below until the image doesn't change
       
       image - binary image to be manipulated
       iterations - # of times to shrink, -1 to shrink until idempotent
       
       There are horizontal/vertical thinners which detect a pixel on
       an edge with an interior pixel either horizontally or vertically
       attached like this:
       0  0  0
       X  1  X
       X  1  X
       and there are much more specific diagonal thinners which detect
       a pixel on the edge of a diagonal, like this:
       0  0  0
       0  1  0
       0  0  1
       Rotate each of these 4x to get the four directions for each
    """
    hv_thinner = numpy.array([[False,False,False],[False,True,False],[False,True,False]])
    hv_anti_thinner = numpy.array([[True,True,True],[False,False,False],[False,False,False]])
    d_thinner = numpy.array([[False,False,False],[False,True,False],[False,False,True]])
    d_anti_thinner = numpy.array([[True,True,True],[True,False,True],[True,True,False]])
    thinners = []
    anti_thinners = []
    for thinner,anti_thinner in ((hv_thinner, hv_anti_thinner),(d_thinner,d_anti_thinner)):
        for n in range(4):
            thinners.append(numpy.lib.rot90(thinner,n))
            anti_thinners.append(numpy.lib.rot90(anti_thinner,n))
    if iterations == -1:
        iterations = 10000
    result = image
    for n in range(iterations):
        temp = result.copy()
        for thinner,anti_thinner in zip(thinners,anti_thinners):
            temp = binary_thin(temp,thinner,anti_thinner)
        if numpy.all(temp==result):
            return result
        result=temp

def strel_disk(radius):
    """Create a disk structuring element for morphological operations
    
    radius - radius of the disk
    """
    iradius = int(radius)
    x,y     = numpy.mgrid[-iradius:iradius+1,-iradius:iradius+1]
    radius2 = radius * radius
    strel   = numpy.zeros(x.shape)
    strel[x*x+y*y <= radius2] = 1
    return strel

def cpmaximum(image, structure=numpy.ones((3,3),dtype=bool),offset=None):
    """Find the local maximum at each point in the image, using the given structuring element
    
    image - a 2-d array of doubles
    structure - a boolean structuring element indicating which
                local elements should be sampled
    offset - the offset to the center of the structuring element
    """
    if not offset:
        offset = (structure.shape[0]/2,structure.shape[1]/2)
    offset = tuple(offset)
    return _cpmorphology.cpmaximum(image,structure,offset)

def relabel(image):
    """Given a labeled image, relabel each of the objects consecutively
    
    image - a labeled 2-d integer array
    returns - (labeled image, object count) 
    """
    #
    # Build a label table that converts an old label # into
    # labels using the new numbering scheme
    #
    unique_labels = numpy.unique(image)
    consecutive_labels = numpy.array(range(len(unique_labels)+1))
    label_table = numpy.ndarray(((unique_labels[-1]+1),),int)
    for old,new in zip(unique_labels,consecutive_labels):
        label_table[old]=new
    #
    # Use the label table to remap all of the labels
    #
    new_image = label_table[image]
    return (new_image,len(unique_labels)-1)

def convex_hull(labels, indexes=None):
    """Given a labeled image, return a list of points per object ordered by
    angle from an interior point, representing the convex hull.
    
    labels - the label matrix
    indexes - an array of label #s to be processed, defaults to all non-zero
              labels
    
    returns a 3d array of complex numbers where the first dimension is
    the label #, the second dimension is the index into the coordinates,
    and the third dimension is i=0,j=1, the coordinates of each of the 
    convex hull points and a 1d array giving the number of points in the
    convex hull of each label
    """
    if indexes == None:
        indexes = numpy.unique(labels)
        indexes.sort()
        indexes=indexes[indexes!=0]
    else:
        indexes=numpy.array(indexes)
    if len(indexes) == 0:
        return numpy.zeros((0,0,2),int),numpy.zeros((0,),int)
    #
    # An array that converts from label # to index in "indexes"
    anti_indexes = numpy.zeros((numpy.max(indexes)+1,),int)
    anti_indexes[indexes] = range(len(indexes))
    #
    # Reduce the # of points to consider
    #
    outlines = outline(labels)
    centers  = scipy.ndimage.center_of_mass(outlines,outlines, indexes)
    centers = numpy.array([centers])
    centers.shape=(indexes.shape[0],2) # if max_label = 1, you get 1d array
    #
    # Make matrices to hold the results (tried this with sparse & ran into
    # problems). Our initial guess of max # of convex hull pts is pretty big
    # but, if there's overflow, we resize below.
    # 
    result_i = numpy.zeros((len(indexes),100),dtype=int)
    result_j = numpy.zeros((len(indexes),100),dtype=int)
    result_counts = numpy.zeros((len(indexes),),dtype=int)
    #
    #
    # Now make an array with one outline point per row and the following
    # columns:
    #
    # index of label # in indexes array
    # angle of the point relative to the center
    # i coordinate of the point
    # j coordinate of the point
    #
    coords = numpy.argwhere(outlines > 0)
    if len(coords)==0:
        # Every outline of every image is blank
        return numpy.zeros((len(indexes),0,2),int),result_counts
    
    i = coords[:,0]
    j = coords[:,1]
    labels_per_point = labels[i,j]
    anti_indexes_per_point = anti_indexes[labels_per_point]
    centers_per_point = centers[anti_indexes_per_point]
    angle = numpy.arctan2(j-centers_per_point[:,1],i-centers_per_point[:,0])
    a = numpy.zeros((len(i),4))
    a[:,0] = anti_indexes_per_point
    a[:,1] = angle
    a[:,2:] = coords
    #
    # Sort the array first by label # (sort of), then by angle
    #
    order = numpy.lexsort((angle,anti_indexes_per_point))
    a=a[order]
    #
    # Initialize the counts of convex hull points to a ridiculous number
    #
    counts = numpy.ones((len(indexes),),int) * (numpy.product(labels.shape)+1)
    while True:
        #
        # Figure out how many putative convex hull points there are for
        # each label.
        #
        # If the count for a label is 3 or less, it's a convex hull or
        # degenerate case.
        #
        # If the count hasn't changed in an iteration, then we've done
        # as well as we can hope to do.
        #
        v = numpy.ones((a.shape[0],),dtype=int)
        new_counts = scipy.sparse.coo_matrix((v,(a[:,0].astype(int),v*0)),
                                             shape=(len(indexes),1))
        new_counts = new_counts.toarray().flatten()
        finish_me = numpy.logical_or(numpy.logical_and(new_counts > 0,
                                                       new_counts <= 3),
                                     new_counts == counts)
        indexes_to_finish = numpy.argwhere(finish_me)
        keep_me = numpy.logical_and(new_counts > 3,
                                    new_counts < counts)
        indexes_to_keep = numpy.argwhere(keep_me)
        if len(indexes_to_finish):
            result_counts[finish_me] = new_counts[finish_me]
            #
            # Store the coordinates of each of the points to finish
            #
            finish_this_row = finish_me[a[:,0].astype(int)]
            rows_to_finish = numpy.argwhere(finish_this_row).flatten()
            a_to_finish = a[rows_to_finish]
            atf_indexes = a_to_finish[:,0].astype(int) # a[float(1)] doesn't work
            #
            # Map label #s to the index into indexes_to_finish of that label #
            #
            anti_indexes_to_finish = numpy.zeros((len(indexes),),int)
            anti_indexes_to_finish[indexes_to_finish] = range(len(indexes_to_finish))
            #
            # Figure out the indices of each point in a label to be finished.
            # We figure out how much to subtract for each label, then
            # subtract that much from 0:N to get successive indexes at
            # each label.
            #
            finish_idx_base = numpy.zeros((len(indexes_to_finish),),int)
            finish_idx_base[1:]=numpy.cumsum(new_counts[indexes_to_finish])[0:-1]
            finish_idx_bases = finish_idx_base[anti_indexes_to_finish[atf_indexes]]
            finish_idx = (numpy.array(range(a_to_finish.shape[0]))-
                          finish_idx_bases)
            max_idx = numpy.max(finish_idx)
            if max_idx >= result_i.shape[1]:
                # Must resize the results to get more room
                result_i=numpy.reshape(result_i,
                                       (result_i.shape[0],int((max_idx)*1.5)))
                result_j=numpy.reshape(result_j,
                                       (result_j.shape[0],int((max_idx)*1.5)))
            result_i[atf_indexes,finish_idx] = a_to_finish[:,2]
            result_j[atf_indexes,finish_idx] = a_to_finish[:,3]
        if len(indexes_to_keep) == 0:
            break
        #
        # Figure out which points are still available
        #
        rows_to_keep=numpy.argwhere(keep_me[a[:,0].astype(int)]).flatten()
        a = a[rows_to_keep]
        a_label = a[:,0].astype(int)
        centers_per_point = centers_per_point[rows_to_keep]
        counts = new_counts
        #
        # The rule is that the area of the triangle from the center to
        # point N-1 to point N plus the area of the triangle from the center
        # to point N to point N+1 must be greater than the area of the
        # triangle from the center to point N-1 to point N+1 for a point
        # to be on the convex hull.
        # N-1 and N+1 have to be modulo "counts", so we make special arrays
        # to address those situations.
        #
        n_minus_one = numpy.array(range(-1,a.shape[0]-1))
        n_plus_one = numpy.array(range(1,a.shape[0]+1))
        anti_indexes = numpy.zeros((len(indexes),),int)
        anti_indexes[indexes_to_keep] = range(len(indexes_to_keep))
        idx_base = numpy.zeros((len(indexes_to_keep),),int)
        idx_base[1:]=numpy.cumsum(counts[indexes_to_keep])[0:-1]
        idx_bases = idx_base[anti_indexes[a_label]]
        idx = numpy.array(range(a.shape[0]),int)-idx_bases
        n_minus_one[idx==0] = counts[a_label[idx==0]]-1
        wrap_high = (idx==counts[a_label]-1) 
        n_plus_one[wrap_high] = 0
        #
        # Compute the triangle areas
        #
        t_left = triangle_areas(centers_per_point,
                                a[n_minus_one,2:],
                                a[:,2:])
        t_right = triangle_areas(centers_per_point,
                                 a[:,2:],
                                 a[n_plus_one,2:])
        t_lr = triangle_areas(centers_per_point,
                              a[n_minus_one,2:],a[n_plus_one,2:])
        #
        # Keep the points where the area of the left triangle plus the
        # area of the right triangle is bigger than the area of the triangle
        # composed of the points to the left and right. This means that
        # there's a little triangle sitting on top of t_lr with our point
        # on top and convex in relation to its neighbors.
        #
        keep_me = t_left+t_right > t_lr
        #
        # If all points on a line are co-linear with the center, then the
        # whole line goes away. Special handling for this to find the points
        # most distant from the center and on the same side
        #
        consider_me = t_left+t_right == 0
        if numpy.any(consider_me):
            diff_i = a[consider_me,2]-centers_per_point[consider_me,0]
            diff_j = a[consider_me,3]-centers_per_point[consider_me,1]
            #
            # The manhattan distance is good enough
            #
            dist = numpy.abs(diff_i)+numpy.abs(diff_j)
            # The sign is different on different sides of a line including
            # the center. Multiply j by 2 to keep from colliding with i
            #
            sign = numpy.sign(diff_i) + numpy.sign(diff_j)*2
            n_minus_one_consider = n_minus_one[consider_me]
            n_plus_one_consider = n_plus_one[consider_me]
            left_is_worse = numpy.logical_or(dist > dist[n_minus_one_consider],
                                             sign != sign[n_minus_one_consider])
            right_is_worse = numpy.logical_or(dist > dist[n_plus_one_consider],
                                              sign != sign[n_plus_one_consider])
            keep_me[consider_me] = numpy.logical_and(left_is_worse,
                                                     right_is_worse)
            
        a = a[keep_me,:]
    #
    # Convert the sparse COO to the array we want to return
    #
    max_count = numpy.max(result_counts)
    result = numpy.zeros((len(indexes),max_count,2),int)
    result[:,:,0]=result_i[:,:max_count]
    result[:,:,1]=result_j[:,:max_count]
    return result, result_counts

def triangle_areas(p1,p2,p3):
    """Compute an array of triangle areas given three arrays of triangle pts
    
    p1,p2,p3 - three Nx2 arrays of points
    """
    v1 = p2-p1
    v2 = p3-p1
    cross1 = v1[:,0] * v2[:,1]
    cross2 = v2[:,0] * v1[:,1]
    a = (cross1-cross2) / 2
    return a  

def draw_line(labels,pt0,pt1,value=1):
    """Draw a line between two points
    
    Uses the Bresenham algorithm
    Some code transcribed from http://www.cs.unc.edu/~mcmillan/comp136/Lecture6/Lines.html
    """
    x0,y0 = pt0
    x1,y1 = pt1
    diff_y = abs(y1-y0)
    diff_x = abs(x1-x0)
    x = x0
    y = y0
    labels[y,x]=value
    step_x = (x1 > x0 and 1) or -1
    step_y = (y1 > y0 and 1) or -1
    if diff_y > diff_x:
        # Y varies fastest, do x before y
        remainder = diff_x*2 - diff_y
        while y != y1:
            if remainder >= 0:
                 x += step_x
                 remainder -= diff_y*2
            y += step_y
            remainder += diff_x*2
            labels[y,x] = value
    else:
        remainder = diff_y*2 - diff_x
        while x != x1:
            if remainder >= 0:
                 y += step_y
                 remainder -= diff_x*2
            x += step_x
            remainder += diff_y*2
            labels[y,x] = value
        
